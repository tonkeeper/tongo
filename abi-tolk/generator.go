//go:build ignore

package main

import (
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	parser "github.com/tonkeeper/tongo/abi-tolk/parser"
	"github.com/tonkeeper/tongo/tolk"
)

const HEADER = `package abitolk
// Code autogenerated. DO NOT EDIT. 

import (
%v
)

`
const SCHEMAS_PATH = "schemas/"

func mergeMethods(abis []tolk.ABI) (map[string][]parser.GetMethodWithAbi, error) {
	methodsMap := map[string][]parser.GetMethodWithAbi{}
	for _, abi := range abis {
		for _, method := range abi.GetMethods {
			current, ok := methodsMap[method.Name]
			if !ok {
				methodsMap[method.Name] = append(methodsMap[method.Name], parser.GetMethodWithAbi{
					ABI:       abi,
					GetMethod: method,
				})
				continue
			}
			if len(current[0].GetMethod.Parameters) != len(method.Parameters) {
				return nil, fmt.Errorf("method '%s' has a version with input params, it has to be defined with golang_name to avoid collision", method.Name)
			}
			current = append(current, parser.GetMethodWithAbi{
				ABI:       abi,
				GetMethod: method,
			})
			methodsMap[method.Name] = current
		}
	}

	return methodsMap, nil
}

func main() {
	var abi []tolk.ABI
	filepath.Walk(SCHEMAS_PATH, func(path string, info fs.FileInfo, err error) error {
		if !strings.HasSuffix(info.Name(), ".json") {
			return nil
		}
		scheme, err := os.ReadFile(path)
		if err != nil {
			panic(err)
		}
		a, err := parser.ParseABI(scheme)
		if err != nil {
			panic(err)
		}
		abi = append(abi, a)
		return nil
	})

	uniqueGetMethods, err := mergeMethods(abi)
	if err != nil {
		panic(err)
	}

	gen := parser.NewGenerator(abi, uniqueGetMethods)
	types := gen.CollectedTypes()
	msgDecoder := gen.GenerateMsgDecoder()

	getMethods, simpleMethods, err := gen.GetMethods()
	if err != nil {
		panic(err)
	}
	invocationOrder, err := gen.RenderInvocationOrderList(simpleMethods)
	if err != nil {
		panic(err)
	}
	messagesMD, err := gen.RenderMessagesMD()
	if err != nil {
		panic(err)
	}
	payloads, err := gen.RenderPayload()
	if err != nil {
		panic(err)
	}
	contractErrors, err := gen.RenderContractErrors()
	if err != nil {
		panic(err)
	}

	for _, f := range [][]string{
		{types, "types.go", `"github.com/tonkeeper/tongo/tlb"`, `"fmt"`, `"encoding/json"`},
		{msgDecoder, "messages_generated.go", `"github.com/tonkeeper/tongo/tlb"`},
		{getMethods, "get_methods.go", `"context"`, `"fmt"`, `"github.com/tonkeeper/tongo/ton"`, `"github.com/tonkeeper/tongo/tlb"`},
		{invocationOrder, "interfaces.go", `"github.com/tonkeeper/tongo/ton"`},
		{payloads, "payload_msg_types.go", `"github.com/tonkeeper/tongo/boc"`, `"github.com/tonkeeper/tongo/tlb"`},
		{contractErrors, "contracts_errors.go"},
	} {
		file, err := os.Create(f[1])
		if err != nil {
			panic(err)
		}
		code := []byte(fmt.Sprintf(HEADER, strings.Join(f[2:], "\n")) + f[0])
		formatedCode, err := format.Source(code)
		if err != nil {
			formatedCode = code
			//panic(err)
		}
		_, err = file.Write(formatedCode)
		if err != nil {
			panic(err)
		}
		err = file.Close()
		if err != nil {
			panic(err)
		}
	}
	if err := os.WriteFile("messages.md", []byte(messagesMD), 0644); err != nil {
		panic(err)
	}
}
