package abi

// Code autogenerated. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/tonkeeper/tongo"
	"github.com/tonkeeper/tongo/boc"
	"github.com/tonkeeper/tongo/tlb"
)

type ContentData struct {
	tlb.SumType
	Snake struct {
		Data tlb.SnakeData
	} `tlbSumType:"#00"`
	Chunks struct {
		Data tlb.ChunkedData
	} `tlbSumType:"#01"`
}

type FullContent struct {
	tlb.SumType
	Onchain struct {
		Data tlb.HashmapE[tlb.Bits256, tlb.Ref[ContentData]]
	} `tlbSumType:"#00"`
	Offchain struct {
		Uri tlb.Text
	} `tlbSumType:"#01"`
}

type ClosingConfig struct {
	QuarantinDuration        uint32
	MisbehaviorFine          tlb.Grams
	ConditionalCloseDuration uint32
}

type ConditionalPayment struct {
	Amount    tlb.Grams
	Condition tlb.Any
}

type PaymentConfig struct {
	ExcessFee tlb.Grams
	DestA     tlb.MsgAddress
	DestB     tlb.MsgAddress
}

type QuarantinedState struct {
	StateA           SemiChannelBody
	StateB           SemiChannelBody
	QuarantineStarts uint32
	StateCommitedByA bool
}

type SemiChannel struct {
	Magic            tlb.Magic `tlb:"#43685374"`
	ChannelId        tlb.Uint128
	Data             SemiChannelBody
	CounterpartyData tlb.Maybe[tlb.Ref[SemiChannelBody]]
}

type SemiChannelBody struct {
	Seqno        uint64
	Sent         tlb.Grams
	Conditionals tlb.HashmapE[tlb.Uint32, ConditionalPayment]
}

type SignedSemiChannel struct {
	Signature tlb.Bits512
	State     SemiChannel
}

type Storage struct {
	BalanceA       tlb.Grams
	BalanceB       tlb.Grams
	KeyA           tlb.Uint256
	KeyB           tlb.Uint256
	ChannelId      tlb.Uint128
	Config         tlb.Ref[ClosingConfig]
	CommitedSeqnoA uint32
	CommitedSeqnoB uint32
	Quarantin      tlb.Maybe[tlb.Ref[QuarantinedState]]
	Payments       tlb.Ref[PaymentConfig]
}

type TorrentInfo struct {
	PieceSize      uint32
	FileSize       uint64
	RootHash       tlb.Uint256
	HeaderSize     uint64
	HeaderHash     tlb.Uint256
	MicrochunkHash tlb.Maybe[tlb.Uint256]
	Description    tlb.Text
}

type NftRoyaltyParams struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type TeleitemAuctionConfig struct {
	BeneficiarAddress tlb.MsgAddress
	InitialMinBid     tlb.Grams
	MaxBid            tlb.Grams
	MinBidStep        uint8
	MinExtendTime     uint32
	Duration          uint32
}

type TelemintData struct {
	Touched           bool
	SubwalletId       uint32
	PublicKey         tlb.Bits256
	CollectionContent tlb.Ref[tlb.Any]
	NftItemCode       tlb.Ref[tlb.Any]
	RoyaltyParams     tlb.Ref[NftRoyaltyParams]
}

type TelemintRestrictions struct {
	ForceSenderAddress   tlb.Maybe[tlb.MsgAddress]
	RewriteSenderAddress tlb.Maybe[tlb.MsgAddress]
}

type TelemintUnsignedDeploy struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
}

type TelemintUnsignedDeployV2 struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	TokenName     tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
	Restrictions  tlb.Maybe[tlb.Ref[TelemintRestrictions]]
}

type TextCommentMsgBody struct {
	Text tlb.Text
}

type ProveOwnershipMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type NftOwnershipAssignedMsgBody struct {
	QueryId        uint64
	PrevOwner      tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type OwnershipProofMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type ChallengeQuarantinedChannelStateMsgBody struct {
	ChallengedByA bool
	Signature     tlb.Bits512
	Tag           uint32
	ChannelId     tlb.Uint128
	SchA          tlb.Ref[SignedSemiChannel]
	SchB          tlb.Ref[SignedSemiChannel]
}

type SbtOwnerInfoMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Initiator tlb.MsgAddress
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type InitPaymentChannelMsgBody struct {
	IsA       bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
}

type JettonTransferMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	Destination         tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardTonAmount    tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type OfferStorageContractMsgBody struct {
	QueryId uint64
}

type JettonInternalTransferMsgBody struct {
	QueryId          uint64
	Amount           tlb.VarUInteger16
	From             tlb.MsgAddress
	ResponseAddress  tlb.MsgAddress
	ForwardTonAmount tlb.VarUInteger16
}

type SbtDestroyMsgBody struct {
	QueryId uint64
}

type StartUncooperativeChannelCloseMsgBody struct {
	SignedByA bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	SchA      tlb.Ref[SignedSemiChannel]
	SchB      tlb.Ref[SignedSemiChannel]
}

type FinishUncooperativeChannelCloseMsgBody struct{}

type TeleitemDeployMsgBody struct {
	SenderAddress tlb.MsgAddress
	Bid           tlb.Grams
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Ref[NftRoyaltyParams]
}

type GetStaticDataMsgBody struct {
	QueryId uint64
}

type TeleitemCancelAuctionMsgBody struct {
	QueryId int64
}

type ProofStorageMsgBody struct {
	QueryId       uint64
	FileDictProof tlb.Ref[tlb.Any]
}

type TelemintDeployMsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeploy
}

type TelemintDeployV2MsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeployV2
}

type StorageWithdrawMsgBody struct {
	QueryId uint64
}

type TeleitemStartAuctionMsgBody struct {
	QueryId       int64
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
}

type UpdatePubkeyMsgBody struct {
	QueryId   uint64
	NewPubkey tlb.Bits256
}

type UpdateStorageParamsMsgBody struct {
	QueryId            uint64
	AcceptNewContracts bool
	RatePerMbDay       tlb.Grams
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

type ChannelCooperativeCloseMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
	SeqnoA    uint64
	SeqnoB    uint64
}

type JettonBurnMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
}

type NftTransferMsgBody struct {
	QueryId             uint64
	NewOwner            tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardAmount       tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type WalletPluginDestructMsgBody struct {
	QueryId uint64
}

type SettleChannelConditionalsMsgBody struct {
	FromA                bool
	Signature            tlb.Bits512
	Tag                  uint32
	ChannelId            tlb.Uint128
	ConditionalsToSettle tlb.HashmapE[tlb.Uint32, tlb.Any]
}

type TopUpChannelBalanceMsgBody struct {
	AddA tlb.Grams
	AddB tlb.Grams
}

type GetRoyaltyParamsMsgBody struct {
	QueryId uint64
}

type SbtRevokeMsgBody struct {
	QueryId uint64
}

type PaymentRequestMsgBody struct {
	QueryId uint64
	Amount  tlb.CurrencyCollection
}

type ChannelCooperativeCommitMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	SeqnoA    uint64
	SeqnoB    uint64
}

type CloseStorageContractMsgBody struct {
	QueryId uint64
}

type AcceptStorageContractMsgBody struct {
	QueryId uint64
}

type ReportStaticDataMsgBody struct {
	QueryId    uint64
	Index      tlb.Uint256
	Collection tlb.MsgAddress
}

type ReportRoyaltyParamsMsgBody struct {
	QueryId     uint64
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type StorageRewardWithdrawalMsgBody struct {
	QueryId uint64
}

type StorageContractTerminatedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type SbtRequestOwnerMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type StorageContractConfirmedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type ExcessMsgBody struct {
	QueryId uint64
}

type ChannelClosedMsgBody struct {
	ChannelId tlb.Uint128
}

type WalletPluginDestructResponseMsgBody struct {
	QueryId uint64
}

type DeployStorageContractMsgBody struct {
	QueryId         uint64
	Info            tlb.Ref[TorrentInfo]
	MerkleHash      tlb.Bits256
	ExpectedRate    tlb.Grams
	ExpectedMaxSpan uint32
}

type PaymentRequestResponseMsgBody struct {
	QueryId uint64
}

func MessageDecoder(cell *boc.Cell) (string, any, error) {
	tag, err := cell.ReadUint(32)
	if err != nil {
		return "", nil, err
	}
	switch tag {
	case 0x0:
		var res TextCommentMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TextComment", res, err
	case 0x4ded148:
		var res ProveOwnershipMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ProveOwnership", res, err
	case 0x5138d91:
		var res NftOwnershipAssignedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "NftOwnershipAssigned", res, err
	case 0x524c7ae:
		var res OwnershipProofMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "OwnershipProof", res, err
	case 0x88eaa32:
		var res ChallengeQuarantinedChannelStateMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChallengeQuarantinedChannelState", res, err
	case 0xdd607e3:
		var res SbtOwnerInfoMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtOwnerInfo", res, err
	case 0xe0620c2:
		var res InitPaymentChannelMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "InitPaymentChannel", res, err
	case 0xf8a7ea5:
		var res JettonTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonTransfer", res, err
	case 0x107c49ef:
		var res OfferStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "OfferStorageContract", res, err
	case 0x178d4519:
		var res JettonInternalTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonInternalTransfer", res, err
	case 0x1f04537a:
		var res SbtDestroyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtDestroy", res, err
	case 0x1f151acf:
		var res StartUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StartUncooperativeChannelClose", res, err
	case 0x25432a91:
		var res FinishUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "FinishUncooperativeChannelClose", res, err
	case 0x299a3e15:
		var res TeleitemDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemDeploy", res, err
	case 0x2fcb26a2:
		var res GetStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "GetStaticData", res, err
	case 0x371638ae:
		var res TeleitemCancelAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemCancelAuction", res, err
	case 0x419d5d4d:
		var res ProofStorageMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ProofStorage", res, err
	case 0x4637289a:
		var res TelemintDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TelemintDeploy", res, err
	case 0x4637289b:
		var res TelemintDeployV2MsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TelemintDeployV2", res, err
	case 0x46ed2e94:
		var res StorageWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageWithdraw", res, err
	case 0x487a8e81:
		var res TeleitemStartAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemStartAuction", res, err
	case 0x53f34cd6:
		var res UpdatePubkeyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "UpdatePubkey", res, err
	case 0x54cbf19b:
		var res UpdateStorageParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "UpdateStorageParams", res, err
	case 0x5577587e:
		var res ChannelCooperativeCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelCooperativeClose", res, err
	case 0x595f07bc:
		var res JettonBurnMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonBurn", res, err
	case 0x5fcc3d14:
		var res NftTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "NftTransfer", res, err
	case 0x64737472:
		var res WalletPluginDestructMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletPluginDestruct", res, err
	case 0x66f6f069:
		var res SettleChannelConditionalsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SettleChannelConditionals", res, err
	case 0x67c7d281:
		var res TopUpChannelBalanceMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TopUpChannelBalance", res, err
	case 0x693d3950:
		var res GetRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "GetRoyaltyParams", res, err
	case 0x6f89f5e3:
		var res SbtRevokeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtRevoke", res, err
	case 0x706c7567:
		var res PaymentRequestMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentRequest", res, err
	case 0x79a126ef:
		var res ChannelCooperativeCommitMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelCooperativeCommit", res, err
	case 0x79f937ea:
		var res CloseStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "CloseStorageContract", res, err
	case 0x7a361688:
		var res AcceptStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "AcceptStorageContract", res, err
	case 0x8b771735:
		var res ReportStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ReportStaticData", res, err
	case 0xa8cb00ad:
		var res ReportRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ReportRoyaltyParams", res, err
	case 0xa91baf56:
		var res StorageRewardWithdrawalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageRewardWithdrawal", res, err
	case 0xb6236d63:
		var res StorageContractTerminatedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractTerminated", res, err
	case 0xd0c3bfea:
		var res SbtRequestOwnerMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtRequestOwner", res, err
	case 0xd4caedcd:
		var res StorageContractConfirmedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractConfirmed", res, err
	case 0xd53276db:
		var res ExcessMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Excess", res, err
	case 0xdddc88ba:
		var res ChannelClosedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelClosed", res, err
	case 0xe4737472:
		var res WalletPluginDestructResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletPluginDestructResponse", res, err
	case 0xe4748df1:
		var res DeployStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "DeployStorageContract", res, err
	case 0xf06c7567:
		var res PaymentRequestResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentRequestResponse", res, err
	}
	return "", nil, fmt.Errorf("invalid message tag")
}

var KnownSimpleGetMethods = map[int][]func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error){
	69506:  {GetTelemintTokenName},
	71463:  {GetTorrentHash},
	72748:  {GetSaleData},
	78748:  {GetPublicKey},
	81467:  {GetSubwalletId},
	81490:  {GetNextProofInfo},
	84760:  {GetAuthorityAddress},
	85143:  {Seqno},
	85719:  {RoyaltyParams},
	86593:  {GetStorageContractData},
	97026:  {GetWalletData},
	97667:  {GetRevokedTime},
	102351: {GetNftData},
	102491: {GetCollectionData},
	104346: {GetStorageParams},
	106029: {GetJettonData},
	106901: {GetChannelState},
	107653: {GetPluginList},
	111161: {ListNominators},
	115150: {GetParams},
	120146: {GetPoolStatus},
	122058: {IsActive},
	122498: {GetTelemintAuctionState},
	123928: {GetStakingStatus},
	127654: {GetMembers},
	129619: {GetTelemintAuctionConfig},
	130271: {GetWalletParams},
	130309: {ListVotes},
}

var ResultTypes = []interface{}{
	&Dnsresolve_RecordResult{},
	&Dnsresolve_RecordsResult{},
	&GetAuthorityAddressResult{},
	&GetChannelStateResult{},
	&GetCollectionDataResult{},
	&GetJettonDataResult{},
	&GetMembers_WhalesNominatorResult{},
	&GetNextProofInfoResult{},
	&GetNftAddressByIndexResult{},
	&GetNftContentResult{},
	&GetNftDataResult{},
	&GetParams_WhalesNominatorResult{},
	&GetPluginListResult{},
	&GetPoolStatusResult{},
	&GetPublicKeyResult{},
	&GetRevokedTimeResult{},
	&GetSaleData_BasicResult{},
	&GetSaleData_GetgemsAuctionResult{},
	&GetSaleData_GetgemsResult{},
	&GetStakingStatusResult{},
	&GetStorageContractAddressResult{},
	&GetStorageContractDataResult{},
	&GetStorageParamsResult{},
	&GetSubwalletIdResult{},
	&GetTelemintAuctionConfigResult{},
	&GetTelemintAuctionStateResult{},
	&GetTelemintTokenNameResult{},
	&GetTorrentHashResult{},
	&GetWalletAddressResult{},
	&GetWalletDataResult{},
	&GetWalletParamsResult{},
	&IsActiveResult{},
	&IsPluginInstalledResult{},
	&ListNominatorsResult{},
	&ListVotesResult{},
	&RoyaltyParamsResult{},
	&SeqnoResult{},
}

type Executor interface {
	RunSmcMethodByID(ctx context.Context, accountID tongo.AccountID, methodID int, params tlb.VmStack) (uint32, tlb.VmStack, error)
}

type SeqnoResult struct {
	State uint32
}

func Seqno(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85143 for "seqno" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85143, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result SeqnoResult
	err = stack.Unmarshal(&result)
	return "SeqnoResult", result, err
}

type GetPublicKeyResult struct {
	PublicKey tlb.Int257
}

func GetPublicKey(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78748 for "get_public_key" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetPublicKeyResult
	err = stack.Unmarshal(&result)
	return "GetPublicKeyResult", result, err
}

type GetSubwalletIdResult struct {
	SubwalletId uint32
}

func GetSubwalletId(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81467 for "get_subwallet_id" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81467, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetSubwalletIdResult
	err = stack.Unmarshal(&result)
	return "GetSubwalletIdResult", result, err
}

type GetPluginListResult struct {
	Plugins []struct {
		Workchain int32
		Address   tlb.Bits256
	}
}

func GetPluginList(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107653 for "get_plugin_list" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107653, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetPluginListResult
	err = stack.Unmarshal(&result)
	return "GetPluginListResult", result, err
}

type IsPluginInstalledResult struct {
	Success bool
}

func IsPluginInstalled(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, workchain int32, addrHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(workchain)}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: addrHash}
	stack.Put(val)

	// MethodID = 76407 for "is_plugin_installed" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 76407, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result IsPluginInstalledResult
	err = stack.Unmarshal(&result)
	return "IsPluginInstalledResult", result, err
}

type GetNftDataResult struct {
	Init              bool
	Index             tlb.Int257
	CollectionAddress tlb.MsgAddress
	OwnerAddress      tlb.MsgAddress
	IndividualContent tlb.Any
}

func GetNftData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102351 for "get_nft_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102351, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetNftDataResult
	err = stack.Unmarshal(&result)
	return "GetNftDataResult", result, err
}

type GetNftContentResult struct {
	Content FullContent
}

func GetNftContent(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257, individualContent tlb.Any) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCell(individualContent)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 68445 for "get_nft_content" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 68445, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetNftContentResult
	err = stack.Unmarshal(&result)
	return "GetNftContentResult", result, err
}

type GetCollectionDataResult struct {
	NextItemIndex     tlb.Int257
	CollectionContent tlb.Any
	OwnerAddress      tlb.MsgAddress
}

func GetCollectionData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102491 for "get_collection_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102491, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetCollectionDataResult
	err = stack.Unmarshal(&result)
	return "GetCollectionDataResult", result, err
}

type GetNftAddressByIndexResult struct {
	Address tlb.MsgAddress
}

func GetNftAddressByIndex(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)

	// MethodID = 92067 for "get_nft_address_by_index" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92067, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetNftAddressByIndexResult
	err = stack.Unmarshal(&result)
	return "GetNftAddressByIndexResult", result, err
}

type RoyaltyParamsResult struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

func RoyaltyParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85719 for "royalty_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85719, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result RoyaltyParamsResult
	err = stack.Unmarshal(&result)
	return "RoyaltyParamsResult", result, err
}

type GetJettonDataResult struct {
	TotalSupply      tlb.Int257
	Mintable         int8
	AdminAddress     tlb.MsgAddress
	JettonContent    tlb.Any
	JettonWalletCode tlb.Any
}

func GetJettonData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106029 for "get_jetton_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106029, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetJettonDataResult
	err = stack.Unmarshal(&result)
	return "GetJettonDataResult", result, err
}

type GetWalletAddressResult struct {
	JettonWalletAddress tlb.MsgAddress
}

func GetWalletAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, ownerAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(ownerAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 103289 for "get_wallet_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103289, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetWalletAddressResult
	err = stack.Unmarshal(&result)
	return "GetWalletAddressResult", result, err
}

type GetWalletDataResult struct {
	Balance          tlb.Int257
	Owner            tlb.MsgAddress
	Jetton           tlb.MsgAddress
	JettonWalletCode tlb.Any
}

func GetWalletData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97026 for "get_wallet_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97026, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetWalletDataResult
	err = stack.Unmarshal(&result)
	return "GetWalletDataResult", result, err
}

type Dnsresolve_RecordResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecord
}

type Dnsresolve_RecordsResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecordSet
}

func Dnsresolve(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, domain []byte, category tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(domain)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: category}
	stack.Put(val)

	// MethodID = 123660 for "dnsresolve" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123660, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){decodeDnsresolve_RecordResult, decodeDnsresolve_RecordsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func decodeDnsresolve_RecordResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var resolvedBits int64
	resolvedBits = int64(stack[0].Int64())
	var result tlb.DNSRecord
	resultCell := &stack[1].VmStkCell.Value
	err = tlb.Unmarshal(resultCell, &result)
	if err != nil {
		return "", nil, err
	}
	return "Dnsresolve_RecordResult", Dnsresolve_RecordResult{
		ResolvedBits: resolvedBits,
		Result:       result,
	}, nil
}

func decodeDnsresolve_RecordsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var resolvedBits int64
	resolvedBits = int64(stack[0].Int64())
	var result tlb.DNSRecordSet
	resultCell := &stack[1].VmStkCell.Value
	err = tlb.Unmarshal(resultCell, &result)
	if err != nil {
		return "", nil, err
	}
	return "Dnsresolve_RecordsResult", Dnsresolve_RecordsResult{
		ResolvedBits: resolvedBits,
		Result:       result,
	}, nil
}

type GetSaleData_BasicResult struct {
	Marketplace    tlb.MsgAddress
	Nft            tlb.MsgAddress
	Owner          tlb.MsgAddress
	FullPrice      tlb.Int257
	MarketFee      uint64
	RoyaltyAddress tlb.MsgAddress
	RoyaltyAmount  uint64
}

type GetSaleData_GetgemsResult struct {
	Magic            uint64
	IsComplete       bool
	CreatedAt        uint64
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	FullPrice        tlb.Int257
	MarketFeeAddress tlb.MsgAddress
	MarketFee        uint64
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyAmount    uint64
}

type GetSaleData_GetgemsAuctionResult struct {
	Magic            uint64
	End              bool
	EndTime          uint32
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	LastBid          uint64
	LastMember       tlb.MsgAddress
	MinStep          uint64
	MarketFeeAddress tlb.MsgAddress
	MpFeeFactor      uint32
	MpFeeBase        uint32
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyFeeFactor uint32
	RoyaltyFeeBase   uint32
	MaxBid           uint64
	MinBid           uint64
	CreatedAt        uint32
	LastBidAt        uint32
	IsCanceled       bool
}

func GetSaleData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){decodeGetSaleData_BasicResult, decodeGetSaleData_GetgemsResult, decodeGetSaleData_GetgemsAuctionResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func decodeGetSaleData_BasicResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var marketplace tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&marketplace)
	if err != nil {
		return "", nil, err
	}
	var nft tlb.MsgAddress
	err = stack[1].VmStkSlice.UnmarshalToTlbStruct(&nft)
	if err != nil {
		return "", nil, err
	}
	var owner tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var fullPrice tlb.Int257
	fullPrice = stack[3].Int257()
	var marketFee uint64
	marketFee = uint64(stack[4].Int64())
	var royaltyAddress tlb.MsgAddress
	err = stack[5].VmStkSlice.UnmarshalToTlbStruct(&royaltyAddress)
	if err != nil {
		return "", nil, err
	}
	var royaltyAmount uint64
	royaltyAmount = uint64(stack[6].Int64())
	return "GetSaleData_BasicResult", GetSaleData_BasicResult{
		Marketplace:    marketplace,
		Nft:            nft,
		Owner:          owner,
		FullPrice:      fullPrice,
		MarketFee:      marketFee,
		RoyaltyAddress: royaltyAddress,
		RoyaltyAmount:  royaltyAmount,
	}, nil
}

func decodeGetSaleData_GetgemsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var magic uint64
	magic = uint64(stack[0].Int64())
	if magic != 0x46495850 {
		return "", nil, fmt.Errorf("required value mismatch")
	}
	var isComplete bool
	isComplete = stack[1].Int64() != 0
	var createdAt uint64
	createdAt = uint64(stack[2].Int64())
	var marketplace tlb.MsgAddress
	err = stack[3].VmStkSlice.UnmarshalToTlbStruct(&marketplace)
	if err != nil {
		return "", nil, err
	}
	var nft tlb.MsgAddress
	err = stack[4].VmStkSlice.UnmarshalToTlbStruct(&nft)
	if err != nil {
		return "", nil, err
	}
	var owner tlb.MsgAddress
	err = stack[5].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var fullPrice tlb.Int257
	fullPrice = stack[6].Int257()
	var marketFeeAddress tlb.MsgAddress
	err = stack[7].VmStkSlice.UnmarshalToTlbStruct(&marketFeeAddress)
	if err != nil {
		return "", nil, err
	}
	var marketFee uint64
	marketFee = uint64(stack[8].Int64())
	var royaltyAddress tlb.MsgAddress
	err = stack[9].VmStkSlice.UnmarshalToTlbStruct(&royaltyAddress)
	if err != nil {
		return "", nil, err
	}
	var royaltyAmount uint64
	royaltyAmount = uint64(stack[10].Int64())
	return "GetSaleData_GetgemsResult", GetSaleData_GetgemsResult{
		Magic:            magic,
		IsComplete:       isComplete,
		CreatedAt:        createdAt,
		Marketplace:      marketplace,
		Nft:              nft,
		Owner:            owner,
		FullPrice:        fullPrice,
		MarketFeeAddress: marketFeeAddress,
		MarketFee:        marketFee,
		RoyaltyAddress:   royaltyAddress,
		RoyaltyAmount:    royaltyAmount,
	}, nil
}

func decodeGetSaleData_GetgemsAuctionResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 20 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") || (stack[11].SumType != "VmStkTinyInt") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkTinyInt") || (stack[14].SumType != "VmStkTinyInt") || (stack[15].SumType != "VmStkTinyInt") || (stack[16].SumType != "VmStkTinyInt") || (stack[17].SumType != "VmStkTinyInt") || (stack[18].SumType != "VmStkTinyInt") || (stack[19].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var magic uint64
	magic = uint64(stack[0].Int64())
	if magic != 0x415543 {
		return "", nil, fmt.Errorf("required value mismatch")
	}
	var end bool
	end = stack[1].Int64() != 0
	var endTime uint32
	endTime = uint32(stack[2].Int64())
	var marketplace tlb.MsgAddress
	err = stack[3].VmStkSlice.UnmarshalToTlbStruct(&marketplace)
	if err != nil {
		return "", nil, err
	}
	var nft tlb.MsgAddress
	err = stack[4].VmStkSlice.UnmarshalToTlbStruct(&nft)
	if err != nil {
		return "", nil, err
	}
	var owner tlb.MsgAddress
	err = stack[5].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var lastBid uint64
	lastBid = uint64(stack[6].Int64())
	var lastMember tlb.MsgAddress
	err = stack[7].VmStkSlice.UnmarshalToTlbStruct(&lastMember)
	if err != nil {
		return "", nil, err
	}
	var minStep uint64
	minStep = uint64(stack[8].Int64())
	var marketFeeAddress tlb.MsgAddress
	err = stack[9].VmStkSlice.UnmarshalToTlbStruct(&marketFeeAddress)
	if err != nil {
		return "", nil, err
	}
	var mpFeeFactor uint32
	mpFeeFactor = uint32(stack[10].Int64())
	var mpFeeBase uint32
	mpFeeBase = uint32(stack[11].Int64())
	var royaltyAddress tlb.MsgAddress
	err = stack[12].VmStkSlice.UnmarshalToTlbStruct(&royaltyAddress)
	if err != nil {
		return "", nil, err
	}
	var royaltyFeeFactor uint32
	royaltyFeeFactor = uint32(stack[13].Int64())
	var royaltyFeeBase uint32
	royaltyFeeBase = uint32(stack[14].Int64())
	var maxBid uint64
	maxBid = uint64(stack[15].Int64())
	var minBid uint64
	minBid = uint64(stack[16].Int64())
	var createdAt uint32
	createdAt = uint32(stack[17].Int64())
	var lastBidAt uint32
	lastBidAt = uint32(stack[18].Int64())
	var isCanceled bool
	isCanceled = stack[19].Int64() != 0
	return "GetSaleData_GetgemsAuctionResult", GetSaleData_GetgemsAuctionResult{
		Magic:            magic,
		End:              end,
		EndTime:          endTime,
		Marketplace:      marketplace,
		Nft:              nft,
		Owner:            owner,
		LastBid:          lastBid,
		LastMember:       lastMember,
		MinStep:          minStep,
		MarketFeeAddress: marketFeeAddress,
		MpFeeFactor:      mpFeeFactor,
		MpFeeBase:        mpFeeBase,
		RoyaltyAddress:   royaltyAddress,
		RoyaltyFeeFactor: royaltyFeeFactor,
		RoyaltyFeeBase:   royaltyFeeBase,
		MaxBid:           maxBid,
		MinBid:           minBid,
		CreatedAt:        createdAt,
		LastBidAt:        lastBidAt,
		IsCanceled:       isCanceled,
	}, nil
}

type GetAuthorityAddressResult struct {
	Address tlb.MsgAddress
}

func GetAuthorityAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 84760 for "get_authority_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 84760, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetAuthorityAddressResult
	err = stack.Unmarshal(&result)
	return "GetAuthorityAddressResult", result, err
}

type GetRevokedTimeResult struct {
	Time uint64
}

func GetRevokedTime(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97667 for "get_revoked_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97667, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetRevokedTimeResult
	err = stack.Unmarshal(&result)
	return "GetRevokedTimeResult", result, err
}

type GetChannelStateResult struct {
	State uint64
}

func GetChannelState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106901 for "get_channel_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106901, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetChannelStateResult
	err = stack.Unmarshal(&result)
	return "GetChannelStateResult", result, err
}

type GetWalletParamsResult struct {
	Seqno     uint32
	Subwallet uint32
	PublicKey tlb.Int257
}

func GetWalletParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130271 for "get_wallet_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130271, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetWalletParamsResult
	err = stack.Unmarshal(&result)
	return "GetWalletParamsResult", result, err
}

type GetStorageParamsResult struct {
	AcceptNewContracts bool
	RatePerMbDay       uint64
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

func GetStorageParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104346 for "get_storage_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104346, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetStorageParamsResult
	err = stack.Unmarshal(&result)
	return "GetStorageParamsResult", result, err
}

type GetStorageContractAddressResult struct {
	StorageContractAddress tlb.MsgAddress
}

func GetStorageContractAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, merkleHash tlb.Int257, fileSize uint64, client tlb.MsgAddress, torrentHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: merkleHash}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(fileSize)}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCellSlice(client)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: torrentHash}
	stack.Put(val)

	// MethodID = 119729 for "get_storage_contract_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119729, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetStorageContractAddressResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractAddressResult", result, err
}

type GetStorageContractDataResult struct {
	Active        bool
	Balance       uint64
	Provider      tlb.MsgAddress
	MerkleHash    tlb.Int257
	FileSize      uint64
	NextProof     uint64
	RatePerMbDay  uint64
	MaxSpan       uint32
	LastProofTime uint32
	Client        tlb.MsgAddress
	TorrentHash   tlb.Int257
}

func GetStorageContractData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86593 for "get_storage_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86593, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetStorageContractDataResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractDataResult", result, err
}

type GetTorrentHashResult struct {
	TorrentHash tlb.Int257
}

func GetTorrentHash(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 71463 for "get_torrent_hash" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 71463, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetTorrentHashResult
	err = stack.Unmarshal(&result)
	return "GetTorrentHashResult", result, err
}

type IsActiveResult struct {
	IsActive bool
}

func IsActive(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122058 for "is_active" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122058, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result IsActiveResult
	err = stack.Unmarshal(&result)
	return "IsActiveResult", result, err
}

type GetNextProofInfoResult struct {
	NextProof     uint64
	LastProofTime uint32
	MaxSpan       uint32
}

func GetNextProofInfo(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81490 for "get_next_proof_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetNextProofInfoResult
	err = stack.Unmarshal(&result)
	return "GetNextProofInfoResult", result, err
}

type ListNominatorsResult struct {
	Nominators []struct {
		Address              tlb.Bits256
		Amount               uint64
		PendingDepositAmount uint64
		WithdrawRequested    bool
	}
}

func ListNominators(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 111161 for "list_nominators" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 111161, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result ListNominatorsResult
	err = stack.Unmarshal(&result)
	return "ListNominatorsResult", result, err
}

type ListVotesResult struct {
	Votes []struct {
		ProposalHash   tlb.Bits256
		VoteCreateTime uint32
	}
}

func ListVotes(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130309 for "list_votes" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130309, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result ListVotesResult
	err = stack.Unmarshal(&result)
	return "ListVotesResult", result, err
}

type GetStakingStatusResult struct {
	StakeAt             uint32
	StakeUntil          uint32
	StakeSent           uint64
	QuerySent           bool
	CouldUnlock         bool
	Locked              bool
	ProxyStakeLockFinal bool
}

func GetStakingStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 123928 for "get_staking_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123928, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetStakingStatusResult
	err = stack.Unmarshal(&result)
	return "GetStakingStatusResult", result, err
}

type GetPoolStatusResult struct {
	Balance                int64
	BalanceSent            int64
	BalancePendingDeposits int64
	BalancePendingWithdraw int64
	BalanceWithdraw        int64
}

func GetPoolStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 120146 for "get_pool_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 120146, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetPoolStatusResult
	err = stack.Unmarshal(&result)
	return "GetPoolStatusResult", result, err
}

type GetMembers_WhalesNominatorResult struct {
	Members []struct {
		Address               tlb.MsgAddress
		MemberBalance         int64
		MemberPendingDeposit  int64
		MemberPendingWithdraw int64
		MemberWithdraw        int64
	}
}

func GetMembers(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 127654 for "get_members" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 127654, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetMembers_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMembers_WhalesNominatorResult", result, err
}

type GetParams_WhalesNominatorResult struct {
	Enabled        bool
	UpdatesEnables bool
	MinStake       int64
	DepositFee     int64
	WithdrawFee    int64
	PoolFee        int64
	ReceiptPrice   int64
}

func GetParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 115150 for "get_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 115150, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetParams_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetParams_WhalesNominatorResult", result, err
}

type GetTelemintAuctionStateResult struct {
	Bidder  tlb.MsgAddress
	Bid     int64
	BidTs   int64
	MinBid  int64
	EndTime int64
}

func GetTelemintAuctionState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122498 for "get_telemint_auction_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122498, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetTelemintAuctionStateResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionStateResult", result, err
}

type GetTelemintAuctionConfigResult struct {
	Beneficiar    tlb.MsgAddress
	InitialMinBid int64
	MaxBid        int64
	MinBidStep    int64
	MinExtendTime int64
	Duration      int64
}

func GetTelemintAuctionConfig(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 129619 for "get_telemint_auction_config" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 129619, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetTelemintAuctionConfigResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionConfigResult", result, err
}

type GetTelemintTokenNameResult struct {
	Beneficiar tlb.Text
}

func GetTelemintTokenName(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 69506 for "get_telemint_token_name" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 69506, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	var result GetTelemintTokenNameResult
	err = stack.Unmarshal(&result)
	return "GetTelemintTokenNameResult", result, err
}

type ContractInterface string

// more wallet-related contract interfaces are defined in wallet.go
const (
	NftSale          ContractInterface = "nft_sale"
	NftSaleGetgems   ContractInterface = "nft_sale_getgems"
	PaymentChannel   ContractInterface = "payment_channel"
	StorageContract  ContractInterface = "storage_contract"
	StorageProvider  ContractInterface = "storage_provider"
	Telemint         ContractInterface = "telemint"
	Tep62Collection  ContractInterface = "tep62_collection"
	Tep62Item        ContractInterface = "tep62_item"
	Tep66            ContractInterface = "tep66"
	Tep74            ContractInterface = "tep74"
	Tep85            ContractInterface = "tep85"
	TfNominator      ContractInterface = "tf_nominator"
	Wallet           ContractInterface = "wallet"
	WalletV4R2       ContractInterface = "wallet_v4r2"
	WhalesNominators ContractInterface = "whales_nominators"
)

type InvokeFn func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error)

// MethodDescription describes a particular method and provides a function to execute it.
type MethodDescription struct {
	Name string
	// InvokeFn executes this method on a contract and returns parsed execution results.
	InvokeFn InvokeFn
	// ImplementedBy is a list of contract interfaces that implement this method.
	// All contract interfaces share the same method with the same output type.
	ImplementedBy []ContractInterface
	// ImplementedByFn returns an implemented contract interface based on a type hint from InvokeFn.
	// Contract interfaces share the same method name but output is different for each contract interface.
	// Check GetSaleData out as an example.
	ImplementedByFn func(typeName string) ContractInterface
}

var methodInvocationOrder = []MethodDescription{
	{
		Name:          "get_authority_address",
		InvokeFn:      GetAuthorityAddress,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:          "get_channel_state",
		InvokeFn:      GetChannelState,
		ImplementedBy: []ContractInterface{PaymentChannel},
	},
	{
		Name:          "get_collection_data",
		InvokeFn:      GetCollectionData,
		ImplementedBy: []ContractInterface{Tep62Collection},
	},
	{
		Name:          "get_jetton_data",
		InvokeFn:      GetJettonData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:     "get_members",
		InvokeFn: GetMembers,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetMembers_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_next_proof_info",
		InvokeFn:      GetNextProofInfo,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_nft_data",
		InvokeFn:      GetNftData,
		ImplementedBy: []ContractInterface{Tep62Item},
	},
	{
		Name:     "get_params",
		InvokeFn: GetParams,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetParams_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_plugin_list",
		InvokeFn:      GetPluginList,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_pool_status",
		InvokeFn:      GetPoolStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_public_key",
		InvokeFn:      GetPublicKey,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
	{
		Name:          "get_revoked_time",
		InvokeFn:      GetRevokedTime,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:     "get_sale_data",
		InvokeFn: GetSaleData,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetSaleData_BasicResult":
				return NftSale
			case "GetSaleData_GetgemsAuctionResult":
				return NftSaleGetgems
			case "GetSaleData_GetgemsResult":
				return NftSaleGetgems
			}
			return ""
		},
	},
	{
		Name:          "get_staking_status",
		InvokeFn:      GetStakingStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_storage_contract_data",
		InvokeFn:      GetStorageContractData,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_storage_params",
		InvokeFn:      GetStorageParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "get_subwallet_id",
		InvokeFn:      GetSubwalletId,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_telemint_auction_config",
		InvokeFn:      GetTelemintAuctionConfig,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_auction_state",
		InvokeFn:      GetTelemintAuctionState,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_token_name",
		InvokeFn:      GetTelemintTokenName,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_torrent_hash",
		InvokeFn:      GetTorrentHash,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_wallet_data",
		InvokeFn:      GetWalletData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:          "get_wallet_params",
		InvokeFn:      GetWalletParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "is_active",
		InvokeFn:      IsActive,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "list_nominators",
		InvokeFn:      ListNominators,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "list_votes",
		InvokeFn:      ListVotes,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "royalty_params",
		InvokeFn:      RoyaltyParams,
		ImplementedBy: []ContractInterface{Tep66},
	},
	{
		Name:          "seqno",
		InvokeFn:      Seqno,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
}
