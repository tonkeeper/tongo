package abi

// Code autogenerated. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/tonkeeper/tongo"
	"github.com/tonkeeper/tongo/boc"
	"github.com/tonkeeper/tongo/tlb"
)

type ContentData struct {
	tlb.SumType
	Snake struct {
		Data tlb.SnakeData
	} `tlbSumType:"#00"`
	Chunks struct {
		Data tlb.ChunkedData
	} `tlbSumType:"#01"`
}

type FullContent struct {
	tlb.SumType
	Onchain struct {
		Data tlb.HashmapE[tlb.Bits256, tlb.Ref[ContentData]]
	} `tlbSumType:"#00"`
	Offchain struct {
		Uri tlb.Text
	} `tlbSumType:"#01"`
}

type ClosingConfig struct {
	QuarantinDuration        uint32
	MisbehaviorFine          tlb.Grams
	ConditionalCloseDuration uint32
}

type ConditionalPayment struct {
	Amount    tlb.Grams
	Condition tlb.Any
}

type PaymentConfig struct {
	ExcessFee tlb.Grams
	DestA     tlb.MsgAddress
	DestB     tlb.MsgAddress
}

type QuarantinedState struct {
	StateA           SemiChannelBody
	StateB           SemiChannelBody
	QuarantineStarts uint32
	StateCommitedByA bool
}

type SemiChannel struct {
	Magic            tlb.Magic `tlb:"#43685374"`
	ChannelId        tlb.Uint128
	Data             SemiChannelBody
	CounterpartyData tlb.Maybe[tlb.Ref[SemiChannelBody]]
}

type SemiChannelBody struct {
	Seqno        uint64
	Sent         tlb.Grams
	Conditionals tlb.HashmapE[tlb.Uint32, ConditionalPayment]
}

type SignedSemiChannel struct {
	Signature tlb.Bits512
	State     SemiChannel
}

type Storage struct {
	BalanceA       tlb.Grams
	BalanceB       tlb.Grams
	KeyA           tlb.Uint256
	KeyB           tlb.Uint256
	ChannelId      tlb.Uint128
	Config         tlb.Ref[ClosingConfig]
	CommitedSeqnoA uint32
	CommitedSeqnoB uint32
	Quarantin      tlb.Maybe[tlb.Ref[QuarantinedState]]
	Payments       tlb.Ref[PaymentConfig]
}

type TorrentInfo struct {
	PieceSize      uint32
	FileSize       uint64
	RootHash       tlb.Uint256
	HeaderSize     uint64
	HeaderHash     tlb.Uint256
	MicrochunkHash tlb.Maybe[tlb.Uint256]
	Description    tlb.Text
}

type TextCommentTextCommentInternalMsgBody struct {
	Text tlb.Text
}

type Tep85SbtProveOwnershipInternalMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type Tep62NftItemOwnershipAssignedInternalMsgBody struct {
	QueryId        uint64
	PrevOwner      tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type Tep85SbtOwnershipProofInternalMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type PaymentChannelChallengeQuarantinedStateInternalMsgBody struct {
	ChallengedByA bool
	Signature     tlb.Bits512
	Tag           uint32
	ChannelId     tlb.Uint128
	SchA          tlb.Ref[SignedSemiChannel]
	SchB          tlb.Ref[SignedSemiChannel]
}

type Tep85SbtOwnerInfoInternalMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Initiator tlb.MsgAddress
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type PaymentChannelInitChannelInternalMsgBody struct {
	IsA       bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
}

type Tep74JettonWalletTransferInternalMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	Destination         tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardTonAmount    tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type OfferStorageContractInternalMsgBody struct {
	QueryId uint64
}

type InternalTransferInternalMsgBody struct {
	QueryId          uint64
	Amount           tlb.VarUInteger16
	From             tlb.MsgAddress
	ResponseAddress  tlb.MsgAddress
	ForwardTonAmount tlb.VarUInteger16
}

type Tep85SbtDestroyInternalMsgBody struct {
	QueryId uint64
}

type PaymentChannelStartUncooperativeCloseInternalMsgBody struct {
	SignedByA bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	SchA      tlb.Ref[SignedSemiChannel]
	SchB      tlb.Ref[SignedSemiChannel]
}

type PaymentChannelFinishUncooperativeCloseInternalMsgBody struct{}

type Tep62NftItemGetStaticDataInternalMsgBody struct {
	QueryId uint64
}

type StorageContractProofStorageInternalMsgBody struct {
	QueryId       uint64
	FileDictProof tlb.Ref[tlb.Any]
}

type StorageContractWithdrawInternalMsgBody struct {
	QueryId uint64
}

type StorageProviderUpdatePubkeyInternalMsgBody struct {
	QueryId   uint64
	NewPubkey tlb.Bits256
}

type StorageProviderUpdateStorageParamsInternalMsgBody struct {
	QueryId            uint64
	AcceptNewContracts bool
	RatePerMbDay       tlb.Grams
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

type PaymentChannelCooperativeCloseInternalMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
	SeqnoA    uint64
	SeqnoB    uint64
}

type Tep74JettonWalletBurnInternalMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
}

type Tep62NftItemTransferInternalMsgBody struct {
	QueryId             uint64
	NewOwner            tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardAmount       tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type WalletV4R2DestructInternalMsgBody struct {
	QueryId uint64
}

type PaymentChannelSettleConditionalsInternalMsgBody struct {
	FromA                bool
	Signature            tlb.Bits512
	Tag                  uint32
	ChannelId            tlb.Uint128
	ConditionalsToSettle tlb.HashmapE[tlb.Uint32, tlb.Any]
}

type PaymentChannelTopUpBalanceInternalMsgBody struct {
	AddA tlb.Grams
	AddB tlb.Grams
}

type Tep66NftRoyaltyGetRoyaltyParamsInternalMsgBody struct {
	QueryId uint64
}

type Tep85SbtRevokeInternalMsgBody struct {
	QueryId uint64
}

type WalletV4R2RequestFundsInternalMsgBody struct {
	QueryId uint64
	Amount  tlb.CurrencyCollection
}

type Tep74JettonWalletTransferNotificationInternalMsgBody struct {
	QueryId        uint64
	Amount         tlb.VarUInteger16
	Sender         tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type PaymentChannelCooperativeCommitInternalMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	SeqnoA    uint64
	SeqnoB    uint64
}

type StorageContractCloseContractInternalMsgBody struct {
	QueryId uint64
}

type StorageContractAcceptStorageContractInternalMsgBody struct {
	QueryId uint64
}

type Tep62NftItemReportStaticDataInternalMsgBody struct {
	QueryId    uint64
	Index      tlb.Uint256
	Collection tlb.MsgAddress
}

type Tep66NftRoyaltyReportRoyaltyParamsInternalMsgBody struct {
	QueryId     uint64
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type StorageContractRewardWithdrawalInternalMsgBody struct {
	QueryId uint64
}

type StorageContractTerminatedInternalMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type Tep85SbtRequestOwnerInternalMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type StorageContractStorageContractConfirmedInternalMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type ExcessesInternalMsgBody struct {
	QueryId uint64
}

type PaymentChannelChannelClosedInternalMsgBody struct {
	ChannelId tlb.Uint128
}

type WalletV4R2DestructResponseInternalMsgBody struct {
	QueryId uint64
}

type WalletV4R2PaymentRequestResponseInternalMsgBody struct {
	QueryId uint64
}

func MessageDecoder(cell *boc.Cell) (string, any, error) {
	tag, err := cell.ReadUint(32)
	if err != nil {
		return "", nil, err
	}
	switch tag {
	case 0x0:
		var res TextCommentTextCommentInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TextCommentTextComment", res, err
	case 0x4ded148:
		var res Tep85SbtProveOwnershipInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtProveOwnership", res, err
	case 0x5138d91:
		var res Tep62NftItemOwnershipAssignedInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep62NftItemOwnershipAssigned", res, err
	case 0x524c7ae:
		var res Tep85SbtOwnershipProofInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtOwnershipProof", res, err
	case 0x88eaa32:
		var res PaymentChannelChallengeQuarantinedStateInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelChallengeQuarantinedState", res, err
	case 0xdd607e3:
		var res Tep85SbtOwnerInfoInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtOwnerInfo", res, err
	case 0xe0620c2:
		var res PaymentChannelInitChannelInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelInitChannel", res, err
	case 0xf8a7ea5:
		var res Tep74JettonWalletTransferInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep74JettonWalletTransfer", res, err
	case 0x107c49ef:
		var res OfferStorageContractInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "OfferStorageContract", res, err
	case 0x178d4519:
		var res InternalTransferInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "InternalTransfer", res, err
	case 0x1f04537a:
		var res Tep85SbtDestroyInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtDestroy", res, err
	case 0x1f151acf:
		var res PaymentChannelStartUncooperativeCloseInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelStartUncooperativeClose", res, err
	case 0x25432a91:
		var res PaymentChannelFinishUncooperativeCloseInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelFinishUncooperativeClose", res, err
	case 0x2fcb26a2:
		var res Tep62NftItemGetStaticDataInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep62NftItemGetStaticData", res, err
	case 0x419d5d4d:
		var res StorageContractProofStorageInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractProofStorage", res, err
	case 0x46ed2e94:
		var res StorageContractWithdrawInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractWithdraw", res, err
	case 0x53f34cd6:
		var res StorageProviderUpdatePubkeyInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageProviderUpdatePubkey", res, err
	case 0x54cbf19b:
		var res StorageProviderUpdateStorageParamsInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageProviderUpdateStorageParams", res, err
	case 0x5577587e:
		var res PaymentChannelCooperativeCloseInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelCooperativeClose", res, err
	case 0x595f07bc:
		var res Tep74JettonWalletBurnInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep74JettonWalletBurn", res, err
	case 0x5fcc3d14:
		var res Tep62NftItemTransferInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep62NftItemTransfer", res, err
	case 0x64737472:
		var res WalletV4R2DestructInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletV4R2Destruct", res, err
	case 0x66f6f069:
		var res PaymentChannelSettleConditionalsInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelSettleConditionals", res, err
	case 0x67c7d281:
		var res PaymentChannelTopUpBalanceInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelTopUpBalance", res, err
	case 0x693d3950:
		var res Tep66NftRoyaltyGetRoyaltyParamsInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep66NftRoyaltyGetRoyaltyParams", res, err
	case 0x6f89f5e3:
		var res Tep85SbtRevokeInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtRevoke", res, err
	case 0x706c7567:
		var res WalletV4R2RequestFundsInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletV4R2RequestFunds", res, err
	case 0x7362d09c:
		var res Tep74JettonWalletTransferNotificationInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep74JettonWalletTransferNotification", res, err
	case 0x79a126ef:
		var res PaymentChannelCooperativeCommitInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelCooperativeCommit", res, err
	case 0x79f937ea:
		var res StorageContractCloseContractInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractCloseContract", res, err
	case 0x7a361688:
		var res StorageContractAcceptStorageContractInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractAcceptStorageContract", res, err
	case 0x8b771735:
		var res Tep62NftItemReportStaticDataInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep62NftItemReportStaticData", res, err
	case 0xa8cb00ad:
		var res Tep66NftRoyaltyReportRoyaltyParamsInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep66NftRoyaltyReportRoyaltyParams", res, err
	case 0xa91baf56:
		var res StorageContractRewardWithdrawalInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractRewardWithdrawal", res, err
	case 0xb6236d63:
		var res StorageContractTerminatedInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractTerminated", res, err
	case 0xd0c3bfea:
		var res Tep85SbtRequestOwnerInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Tep85SbtRequestOwner", res, err
	case 0xd4caedcd:
		var res StorageContractStorageContractConfirmedInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractStorageContractConfirmed", res, err
	case 0xd53276db:
		var res ExcessesInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Excesses", res, err
	case 0xdddc88ba:
		var res PaymentChannelChannelClosedInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentChannelChannelClosed", res, err
	case 0xe4737472:
		var res WalletV4R2DestructResponseInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletV4R2DestructResponse", res, err
	case 0xf06c7567:
		var res WalletV4R2PaymentRequestResponseInternalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletV4R2PaymentRequestResponse", res, err
	}
	return "", nil, fmt.Errorf("invalid message tag")
}

var KnownSimpleGetMethods = map[int][]func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error){
	71463:  {GetTorrentHash},
	72748:  {NftSaleGetSaleData, NftSaleGetGemsGetSaleData},
	76407:  {IsPluginInstalled},
	78748:  {GetPublicKey},
	81467:  {GetSubwalletId},
	81490:  {GetNextProofInfo},
	84760:  {GetAuthorityAddress},
	85143:  {Seqno},
	85719:  {RoyaltyParams},
	86593:  {GetStorageContractData},
	97026:  {GetWalletData},
	97667:  {GetRevokedTime},
	102351: {GetNftData},
	102491: {GetCollectionData},
	104346: {GetStorageParams},
	106029: {GetJettonData},
	106901: {GetChannelState},
	122058: {IsActive},
	130271: {GetWalletParams},
}

var ResultTypes = []interface{}{
	&GetAuthorityAddressResult{},
	&GetChannelStateResult{},
	&GetCollectionDataResult{},
	&GetJettonDataResult{},
	&GetNextProofInfoResult{},
	&GetNftAddressByIndexResult{},
	&GetNftContentResult{},
	&GetNftDataResult{},
	&GetPublicKeyResult{},
	&GetRevokedTimeResult{},
	&GetStorageContractAddressResult{},
	&GetStorageContractDataResult{},
	&GetStorageParamsResult{},
	&GetSubwalletIdResult{},
	&GetTorrentHashResult{},
	&GetWalletAddressResult{},
	&GetWalletDataResult{},
	&GetWalletParamsResult{},
	&IsActiveResult{},
	&IsPluginInstalledResult{},
	&NftSaleGetGemsGetSaleDataResult{},
	&NftSaleGetSaleDataResult{},
	&RecordDnsresolveResult{},
	&RecordsDnsresolveResult{},
	&RoyaltyParamsResult{},
	&SeqnoResult{},
}

type Executor interface {
	RunSmcMethodByID(ctx context.Context, accountID tongo.AccountID, methodID int, params tlb.VmStack) (uint32, tlb.VmStack, error)
}

type SeqnoResult struct {
	State uint32
}

func Seqno(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85143 for "seqno" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85143, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeSeqnoResult(stack)
}

func decodeSeqnoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var state uint32
	state = uint32(stack[0].Int64())
	return "SeqnoResult", SeqnoResult{
		State: state,
	}, nil
}

type GetPublicKeyResult struct {
	PublicKey tlb.Int257
}

func GetPublicKey(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78748 for "get_public_key" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetPublicKeyResult(stack)
}

func decodeGetPublicKeyResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var publicKey tlb.Int257
	publicKey = stack[0].Int257()
	return "GetPublicKeyResult", GetPublicKeyResult{
		PublicKey: publicKey,
	}, nil
}

type GetSubwalletIdResult struct {
	SubwalletId uint32
}

func GetSubwalletId(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81467 for "get_subwallet_id" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81467, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetSubwalletIdResult(stack)
}

func decodeGetSubwalletIdResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var subwalletId uint32
	subwalletId = uint32(stack[0].Int64())
	return "GetSubwalletIdResult", GetSubwalletIdResult{
		SubwalletId: subwalletId,
	}, nil
}

type IsPluginInstalledResult struct {
	Success bool
}

func IsPluginInstalled(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 76407 for "is_plugin_installed" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 76407, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeIsPluginInstalledResult(stack)
}

func decodeIsPluginInstalledResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var success bool
	success = stack[0].Int64() != 0
	return "IsPluginInstalledResult", IsPluginInstalledResult{
		Success: success,
	}, nil
}

type GetNftDataResult struct {
	Init              int8
	Index             tlb.Int257
	CollectionAddress tlb.MsgAddress
	OwnerAddress      tlb.MsgAddress
	IndividualContent tlb.Any
}

func GetNftData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102351 for "get_nft_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102351, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetNftDataResult(stack)
}

func decodeGetNftDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var init int8
	init = int8(stack[0].Int64())
	var index tlb.Int257
	index = stack[1].Int257()
	var collectionAddress tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&collectionAddress)
	if err != nil {
		return "", nil, err
	}
	var ownerAddress tlb.MsgAddress
	err = stack[3].VmStkSlice.UnmarshalToTlbStruct(&ownerAddress)
	if err != nil {
		return "", nil, err
	}
	var individualContent tlb.Any
	individualContentCell := &stack[4].VmStkCell.Value
	err = tlb.Unmarshal(individualContentCell, &individualContent)
	if err != nil {
		return "", nil, err
	}
	return "GetNftDataResult", GetNftDataResult{
		Init:              init,
		Index:             index,
		CollectionAddress: collectionAddress,
		OwnerAddress:      ownerAddress,
		IndividualContent: individualContent,
	}, nil
}

type GetNftContentResult struct {
	Content FullContent
}

func GetNftContent(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257, individualContent tlb.Any) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCell(individualContent)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 68445 for "get_nft_content" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 68445, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetNftContentResult(stack)
}

func decodeGetNftContentResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var content FullContent
	contentCell := &stack[0].VmStkCell.Value
	err = tlb.Unmarshal(contentCell, &content)
	if err != nil {
		return "", nil, err
	}
	return "GetNftContentResult", GetNftContentResult{
		Content: content,
	}, nil
}

type GetCollectionDataResult struct {
	NextItemIndex     tlb.Int257
	CollectionContent tlb.Any
	OwnerAddress      tlb.MsgAddress
}

func GetCollectionData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102491 for "get_collection_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102491, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetCollectionDataResult(stack)
}

func decodeGetCollectionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var nextItemIndex tlb.Int257
	nextItemIndex = stack[0].Int257()
	var collectionContent tlb.Any
	collectionContentCell := &stack[1].VmStkCell.Value
	err = tlb.Unmarshal(collectionContentCell, &collectionContent)
	if err != nil {
		return "", nil, err
	}
	var ownerAddress tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&ownerAddress)
	if err != nil {
		return "", nil, err
	}
	return "GetCollectionDataResult", GetCollectionDataResult{
		NextItemIndex:     nextItemIndex,
		CollectionContent: collectionContent,
		OwnerAddress:      ownerAddress,
	}, nil
}

type GetNftAddressByIndexResult struct {
	Address tlb.MsgAddress
}

func GetNftAddressByIndex(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)

	// MethodID = 92067 for "get_nft_address_by_index" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92067, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetNftAddressByIndexResult(stack)
}

func decodeGetNftAddressByIndexResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var address tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&address)
	if err != nil {
		return "", nil, err
	}
	return "GetNftAddressByIndexResult", GetNftAddressByIndexResult{
		Address: address,
	}, nil
}

type RoyaltyParamsResult struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

func RoyaltyParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85719 for "royalty_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85719, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeRoyaltyParamsResult(stack)
}

func decodeRoyaltyParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var numerator uint16
	numerator = uint16(stack[0].Int64())
	var denominator uint16
	denominator = uint16(stack[1].Int64())
	var destination tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&destination)
	if err != nil {
		return "", nil, err
	}
	return "RoyaltyParamsResult", RoyaltyParamsResult{
		Numerator:   numerator,
		Denominator: denominator,
		Destination: destination,
	}, nil
}

type GetJettonDataResult struct {
	TotalSupply      tlb.Int257
	Mintable         int8
	AdminAddress     tlb.MsgAddress
	JettonContent    tlb.Any
	JettonWalletCode tlb.Any
}

func GetJettonData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106029 for "get_jetton_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106029, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetJettonDataResult(stack)
}

func decodeGetJettonDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var totalSupply tlb.Int257
	totalSupply = stack[0].Int257()
	var mintable int8
	mintable = int8(stack[1].Int64())
	var adminAddress tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&adminAddress)
	if err != nil {
		return "", nil, err
	}
	var jettonContent tlb.Any
	jettonContentCell := &stack[3].VmStkCell.Value
	err = tlb.Unmarshal(jettonContentCell, &jettonContent)
	if err != nil {
		return "", nil, err
	}
	var jettonWalletCode tlb.Any
	jettonWalletCodeCell := &stack[4].VmStkCell.Value
	err = tlb.Unmarshal(jettonWalletCodeCell, &jettonWalletCode)
	if err != nil {
		return "", nil, err
	}
	return "GetJettonDataResult", GetJettonDataResult{
		TotalSupply:      totalSupply,
		Mintable:         mintable,
		AdminAddress:     adminAddress,
		JettonContent:    jettonContent,
		JettonWalletCode: jettonWalletCode,
	}, nil
}

type GetWalletAddressResult struct {
	JettonWalletAddress tlb.MsgAddress
}

func GetWalletAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, ownerAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(ownerAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 103289 for "get_wallet_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103289, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetWalletAddressResult(stack)
}

func decodeGetWalletAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var jettonWalletAddress tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&jettonWalletAddress)
	if err != nil {
		return "", nil, err
	}
	return "GetWalletAddressResult", GetWalletAddressResult{
		JettonWalletAddress: jettonWalletAddress,
	}, nil
}

type GetWalletDataResult struct {
	Balance          tlb.Int257
	Owner            tlb.MsgAddress
	Jetton           tlb.MsgAddress
	JettonWalletCode tlb.Any
}

func GetWalletData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97026 for "get_wallet_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97026, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetWalletDataResult(stack)
}

func decodeGetWalletDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var balance tlb.Int257
	balance = stack[0].Int257()
	var owner tlb.MsgAddress
	err = stack[1].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var jetton tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&jetton)
	if err != nil {
		return "", nil, err
	}
	var jettonWalletCode tlb.Any
	jettonWalletCodeCell := &stack[3].VmStkCell.Value
	err = tlb.Unmarshal(jettonWalletCodeCell, &jettonWalletCode)
	if err != nil {
		return "", nil, err
	}
	return "GetWalletDataResult", GetWalletDataResult{
		Balance:          balance,
		Owner:            owner,
		Jetton:           jetton,
		JettonWalletCode: jettonWalletCode,
	}, nil
}

type RecordDnsresolveResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecord
}

type RecordsDnsresolveResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecordSet
}

func Dnsresolve(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, domain []byte, category tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(domain)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: category}
	stack.Put(val)

	// MethodID = 123660 for "dnsresolve" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123660, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){decodeRecordDnsresolveResult, decodeRecordsDnsresolveResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func decodeRecordDnsresolveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var resolvedBits int64
	resolvedBits = int64(stack[0].Int64())
	var result tlb.DNSRecord
	resultCell := &stack[1].VmStkCell.Value
	err = tlb.Unmarshal(resultCell, &result)
	if err != nil {
		return "", nil, err
	}
	return "RecordDnsresolveResult", RecordDnsresolveResult{
		ResolvedBits: resolvedBits,
		Result:       result,
	}, nil
}

func decodeRecordsDnsresolveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var resolvedBits int64
	resolvedBits = int64(stack[0].Int64())
	var result tlb.DNSRecordSet
	resultCell := &stack[1].VmStkCell.Value
	err = tlb.Unmarshal(resultCell, &result)
	if err != nil {
		return "", nil, err
	}
	return "RecordsDnsresolveResult", RecordsDnsresolveResult{
		ResolvedBits: resolvedBits,
		Result:       result,
	}, nil
}

type NftSaleGetSaleDataResult struct {
	Marketplace    tlb.MsgAddress
	Nft            tlb.MsgAddress
	Owner          tlb.MsgAddress
	FullPrice      tlb.Int257
	MarketFee      uint64
	RoyaltyAddress tlb.MsgAddress
	RoyaltyAmount  uint64
}

func NftSaleGetSaleData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeNftSaleGetSaleDataResult(stack)
}

func decodeNftSaleGetSaleDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var marketplace tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&marketplace)
	if err != nil {
		return "", nil, err
	}
	var nft tlb.MsgAddress
	err = stack[1].VmStkSlice.UnmarshalToTlbStruct(&nft)
	if err != nil {
		return "", nil, err
	}
	var owner tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var fullPrice tlb.Int257
	fullPrice = stack[3].Int257()
	var marketFee uint64
	marketFee = uint64(stack[4].Int64())
	var royaltyAddress tlb.MsgAddress
	err = stack[5].VmStkSlice.UnmarshalToTlbStruct(&royaltyAddress)
	if err != nil {
		return "", nil, err
	}
	var royaltyAmount uint64
	royaltyAmount = uint64(stack[6].Int64())
	return "NftSaleGetSaleDataResult", NftSaleGetSaleDataResult{
		Marketplace:    marketplace,
		Nft:            nft,
		Owner:          owner,
		FullPrice:      fullPrice,
		MarketFee:      marketFee,
		RoyaltyAddress: royaltyAddress,
		RoyaltyAmount:  royaltyAmount,
	}, nil
}

type NftSaleGetGemsGetSaleDataResult struct {
	FixPrice         uint64
	IsComplete       bool
	CreatedAt        uint64
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	FullPrice        tlb.Int257
	MarketFeeAddress tlb.MsgAddress
	MarketFee        uint64
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyAmount    uint64
}

func NftSaleGetGemsGetSaleData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeNftSaleGetGemsGetSaleDataResult(stack)
}

func decodeNftSaleGetGemsGetSaleDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var fixPrice uint64
	fixPrice = uint64(stack[0].Int64())
	var isComplete bool
	isComplete = stack[1].Int64() != 0
	var createdAt uint64
	createdAt = uint64(stack[2].Int64())
	var marketplace tlb.MsgAddress
	err = stack[3].VmStkSlice.UnmarshalToTlbStruct(&marketplace)
	if err != nil {
		return "", nil, err
	}
	var nft tlb.MsgAddress
	err = stack[4].VmStkSlice.UnmarshalToTlbStruct(&nft)
	if err != nil {
		return "", nil, err
	}
	var owner tlb.MsgAddress
	err = stack[5].VmStkSlice.UnmarshalToTlbStruct(&owner)
	if err != nil {
		return "", nil, err
	}
	var fullPrice tlb.Int257
	fullPrice = stack[6].Int257()
	var marketFeeAddress tlb.MsgAddress
	err = stack[7].VmStkSlice.UnmarshalToTlbStruct(&marketFeeAddress)
	if err != nil {
		return "", nil, err
	}
	var marketFee uint64
	marketFee = uint64(stack[8].Int64())
	var royaltyAddress tlb.MsgAddress
	err = stack[9].VmStkSlice.UnmarshalToTlbStruct(&royaltyAddress)
	if err != nil {
		return "", nil, err
	}
	var royaltyAmount uint64
	royaltyAmount = uint64(stack[10].Int64())
	return "NftSaleGetGemsGetSaleDataResult", NftSaleGetGemsGetSaleDataResult{
		FixPrice:         fixPrice,
		IsComplete:       isComplete,
		CreatedAt:        createdAt,
		Marketplace:      marketplace,
		Nft:              nft,
		Owner:            owner,
		FullPrice:        fullPrice,
		MarketFeeAddress: marketFeeAddress,
		MarketFee:        marketFee,
		RoyaltyAddress:   royaltyAddress,
		RoyaltyAmount:    royaltyAmount,
	}, nil
}

type GetAuthorityAddressResult struct {
	Address tlb.MsgAddress
}

func GetAuthorityAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 84760 for "get_authority_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 84760, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetAuthorityAddressResult(stack)
}

func decodeGetAuthorityAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var address tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&address)
	if err != nil {
		return "", nil, err
	}
	return "GetAuthorityAddressResult", GetAuthorityAddressResult{
		Address: address,
	}, nil
}

type GetRevokedTimeResult struct {
	Time uint64
}

func GetRevokedTime(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97667 for "get_revoked_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97667, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetRevokedTimeResult(stack)
}

func decodeGetRevokedTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var time uint64
	time = uint64(stack[0].Int64())
	return "GetRevokedTimeResult", GetRevokedTimeResult{
		Time: time,
	}, nil
}

type GetChannelStateResult struct {
	State uint64
}

func GetChannelState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106901 for "get_channel_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106901, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetChannelStateResult(stack)
}

func decodeGetChannelStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var state uint64
	state = uint64(stack[0].Int64())
	return "GetChannelStateResult", GetChannelStateResult{
		State: state,
	}, nil
}

type GetWalletParamsResult struct {
	Seqno     uint32
	Subwallet uint32
	PublicKey tlb.Int257
}

func GetWalletParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130271 for "get_wallet_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130271, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetWalletParamsResult(stack)
}

func decodeGetWalletParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var seqno uint32
	seqno = uint32(stack[0].Int64())
	var subwallet uint32
	subwallet = uint32(stack[1].Int64())
	var publicKey tlb.Int257
	publicKey = stack[2].Int257()
	return "GetWalletParamsResult", GetWalletParamsResult{
		Seqno:     seqno,
		Subwallet: subwallet,
		PublicKey: publicKey,
	}, nil
}

type GetStorageParamsResult struct {
	AcceptNewContracts bool
	RatePerMbDay       uint64
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

func GetStorageParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104346 for "get_storage_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104346, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetStorageParamsResult(stack)
}

func decodeGetStorageParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var acceptNewContracts bool
	acceptNewContracts = stack[0].Int64() != 0
	var ratePerMbDay uint64
	ratePerMbDay = uint64(stack[1].Int64())
	var maxSpan uint32
	maxSpan = uint32(stack[2].Int64())
	var minimalFileSize uint64
	minimalFileSize = uint64(stack[3].Int64())
	var maximalFileSize uint64
	maximalFileSize = uint64(stack[4].Int64())
	return "GetStorageParamsResult", GetStorageParamsResult{
		AcceptNewContracts: acceptNewContracts,
		RatePerMbDay:       ratePerMbDay,
		MaxSpan:            maxSpan,
		MinimalFileSize:    minimalFileSize,
		MaximalFileSize:    maximalFileSize,
	}, nil
}

type GetStorageContractAddressResult struct {
	StorageContractAddress tlb.MsgAddress
}

func GetStorageContractAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, merkleHash tlb.Int257, fileSize uint64, client tlb.MsgAddress, torrentHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: merkleHash}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(fileSize)}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCellSlice(client)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: torrentHash}
	stack.Put(val)

	// MethodID = 119729 for "get_storage_contract_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119729, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetStorageContractAddressResult(stack)
}

func decodeGetStorageContractAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var storageContractAddress tlb.MsgAddress
	err = stack[0].VmStkSlice.UnmarshalToTlbStruct(&storageContractAddress)
	if err != nil {
		return "", nil, err
	}
	return "GetStorageContractAddressResult", GetStorageContractAddressResult{
		StorageContractAddress: storageContractAddress,
	}, nil
}

type GetStorageContractDataResult struct {
	Active        bool
	Balance       uint64
	Provider      tlb.MsgAddress
	MerkleHash    tlb.Int257
	FileSize      uint64
	NextProof     uint64
	RatePerMbDay  uint64
	MaxSpan       uint32
	LastProofTime uint32
	Client        tlb.MsgAddress
	TorrentHash   tlb.Int257
}

func GetStorageContractData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86593 for "get_storage_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86593, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetStorageContractDataResult(stack)
}

func decodeGetStorageContractDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var active bool
	active = stack[0].Int64() != 0
	var balance uint64
	balance = uint64(stack[1].Int64())
	var provider tlb.MsgAddress
	err = stack[2].VmStkSlice.UnmarshalToTlbStruct(&provider)
	if err != nil {
		return "", nil, err
	}
	var merkleHash tlb.Int257
	merkleHash = stack[3].Int257()
	var fileSize uint64
	fileSize = uint64(stack[4].Int64())
	var nextProof uint64
	nextProof = uint64(stack[5].Int64())
	var ratePerMbDay uint64
	ratePerMbDay = uint64(stack[6].Int64())
	var maxSpan uint32
	maxSpan = uint32(stack[7].Int64())
	var lastProofTime uint32
	lastProofTime = uint32(stack[8].Int64())
	var client tlb.MsgAddress
	err = stack[9].VmStkSlice.UnmarshalToTlbStruct(&client)
	if err != nil {
		return "", nil, err
	}
	var torrentHash tlb.Int257
	torrentHash = stack[10].Int257()
	return "GetStorageContractDataResult", GetStorageContractDataResult{
		Active:        active,
		Balance:       balance,
		Provider:      provider,
		MerkleHash:    merkleHash,
		FileSize:      fileSize,
		NextProof:     nextProof,
		RatePerMbDay:  ratePerMbDay,
		MaxSpan:       maxSpan,
		LastProofTime: lastProofTime,
		Client:        client,
		TorrentHash:   torrentHash,
	}, nil
}

type GetTorrentHashResult struct {
	TorrentHash tlb.Int257
}

func GetTorrentHash(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 71463 for "get_torrent_hash" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 71463, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetTorrentHashResult(stack)
}

func decodeGetTorrentHashResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var torrentHash tlb.Int257
	torrentHash = stack[0].Int257()
	return "GetTorrentHashResult", GetTorrentHashResult{
		TorrentHash: torrentHash,
	}, nil
}

type IsActiveResult struct {
	IsActive bool
}

func IsActive(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122058 for "is_active" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122058, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeIsActiveResult(stack)
}

func decodeIsActiveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var isActive bool
	isActive = stack[0].Int64() != 0
	return "IsActiveResult", IsActiveResult{
		IsActive: isActive,
	}, nil
}

type GetNextProofInfoResult struct {
	NextProof     uint64
	LastProofTime uint32
	MaxSpan       uint32
}

func GetNextProofInfo(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81490 for "get_next_proof_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	return decodeGetNextProofInfoResult(stack)
}

func decodeGetNextProofInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var nextProof uint64
	nextProof = uint64(stack[0].Int64())
	var lastProofTime uint32
	lastProofTime = uint32(stack[1].Int64())
	var maxSpan uint32
	maxSpan = uint32(stack[2].Int64())
	return "GetNextProofInfoResult", GetNextProofInfoResult{
		NextProof:     nextProof,
		LastProofTime: lastProofTime,
		MaxSpan:       maxSpan,
	}, nil
}

type ContractInterface string

// more wallet-related contract interfaces are defined in wallet.go
const (
	NftSale            ContractInterface = "nft_sale"
	NftSaleGetgems     ContractInterface = "nft_sale_getgems"
	PaymentChannel     ContractInterface = "payment_channel"
	StorageContract    ContractInterface = "storage_contract"
	StorageProvider    ContractInterface = "storage_provider"
	Tep62NftCollection ContractInterface = "tep_62_nft_collection"
	Tep62NftItem       ContractInterface = "tep_62_nft_item"
	Tep66NftRoyalty    ContractInterface = "tep_66_nft_royalty"
	Tep74JettonMaster  ContractInterface = "tep_74_jetton_master"
	Tep74JettonWallet  ContractInterface = "tep_74_jetton_wallet"
	Tep81Dns           ContractInterface = "tep_81_dns"
	Tep85Sbt           ContractInterface = "tep_85_sbt"
	TextComment        ContractInterface = "text_comment"
	WalletV3R2         ContractInterface = "wallet_v3r2"
	WalletV4R2         ContractInterface = "wallet_v4r2"
)

type InvokeFn func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error)

// MethodDescription describes a particular method and provides a function to execute it.
type MethodDescription struct {
	Name string
	// ImplementedBy is a list of contract interfaces that implement this method.
	ImplementedBy []ContractInterface
	// InvokeFn executes this method on a contract and returns parsed execution results.
	InvokeFn InvokeFn
}

var methodInvocationOrder = []MethodDescription{
	{
		Name:          "get_authority_address",
		ImplementedBy: []ContractInterface{Tep85Sbt},
		InvokeFn:      GetAuthorityAddress,
	},
	{
		Name:          "get_channel_state",
		ImplementedBy: []ContractInterface{PaymentChannel},
		InvokeFn:      GetChannelState,
	},
	{
		Name:          "get_collection_data",
		ImplementedBy: []ContractInterface{Tep62NftCollection},
		InvokeFn:      GetCollectionData,
	},
	{
		Name:          "get_jetton_data",
		ImplementedBy: []ContractInterface{Tep74JettonMaster},
		InvokeFn:      GetJettonData,
	},
	{
		Name:          "get_next_proof_info",
		ImplementedBy: []ContractInterface{StorageContract},
		InvokeFn:      GetNextProofInfo,
	},
	{
		Name:          "get_nft_data",
		ImplementedBy: []ContractInterface{Tep62NftItem},
		InvokeFn:      GetNftData,
	},
	{
		Name:          "get_public_key",
		ImplementedBy: []ContractInterface{StorageProvider, WalletV3R2, WalletV4R2},
		InvokeFn:      GetPublicKey,
	},
	{
		Name:          "get_revoked_time",
		ImplementedBy: []ContractInterface{Tep85Sbt},
		InvokeFn:      GetRevokedTime,
	},
	{
		Name:          "get_sale_data",
		ImplementedBy: []ContractInterface{NftSale},
		InvokeFn:      NftSaleGetSaleData,
	},
	{
		Name:          "get_sale_data",
		ImplementedBy: []ContractInterface{NftSaleGetgems},
		InvokeFn:      NftSaleGetGemsGetSaleData,
	},
	{
		Name:          "get_storage_contract_data",
		ImplementedBy: []ContractInterface{StorageContract},
		InvokeFn:      GetStorageContractData,
	},
	{
		Name:          "get_storage_params",
		ImplementedBy: []ContractInterface{StorageProvider},
		InvokeFn:      GetStorageParams,
	},
	{
		Name:          "get_subwallet_id",
		ImplementedBy: []ContractInterface{WalletV4R2},
		InvokeFn:      GetSubwalletId,
	},
	{
		Name:          "get_torrent_hash",
		ImplementedBy: []ContractInterface{StorageContract},
		InvokeFn:      GetTorrentHash,
	},
	{
		Name:          "get_wallet_data",
		ImplementedBy: []ContractInterface{Tep74JettonWallet},
		InvokeFn:      GetWalletData,
	},
	{
		Name:          "get_wallet_params",
		ImplementedBy: []ContractInterface{StorageProvider},
		InvokeFn:      GetWalletParams,
	},
	{
		Name:          "is_active",
		ImplementedBy: []ContractInterface{StorageContract},
		InvokeFn:      IsActive,
	},
	{
		Name:          "is_plugin_installed",
		ImplementedBy: []ContractInterface{WalletV4R2},
		InvokeFn:      IsPluginInstalled,
	},
	{
		Name:          "royalty_params",
		ImplementedBy: []ContractInterface{Tep66NftRoyalty},
		InvokeFn:      RoyaltyParams,
	},
	{
		Name:          "seqno",
		ImplementedBy: []ContractInterface{StorageProvider, WalletV3R2, WalletV4R2},
		InvokeFn:      Seqno,
	},
}
