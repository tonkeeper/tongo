package abi

// Code autogenerated. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/tonkeeper/tongo/boc"
	"github.com/tonkeeper/tongo/tlb"
	"github.com/tonkeeper/tongo/ton"
)

var KnownGetMethodsDecoder = map[string][]func(tlb.VmStack) (string, any, error){
	"dnsresolve":                    {DecodeDnsresolve_RecordsResult},
	"get_amm_contract_data":         {DecodeGetAmmContractDataResult},
	"get_amm_name":                  {DecodeGetAmmNameResult},
	"get_amm_state":                 {DecodeGetAmmStateResult},
	"get_amm_status":                {DecodeGetAmmStatusResult},
	"get_asset":                     {DecodeGetAsset_DedustResult},
	"get_assets":                    {DecodeGetAssets_DedustResult},
	"get_auction_info":              {DecodeGetAuctionInfoResult},
	"get_authority_address":         {DecodeGetAuthorityAddressResult},
	"get_balances":                  {DecodeGetBalancesResult},
	"get_bill_address":              {DecodeGetBillAddressResult},
	"get_bill_amount":               {DecodeGetBillAmountResult},
	"get_channel_data":              {DecodeGetChannelDataResult},
	"get_collection_data":           {DecodeGetCollectionDataResult},
	"get_domain":                    {DecodeGetDomainResult},
	"get_editor":                    {DecodeGetEditorResult},
	"get_exchange_settings":         {DecodeGetExchangeSettingsResult},
	"get_executor_vaults_whitelist": {DecodeGetExecutorVaultsWhitelistResult},
	"get_full_domain":               {DecodeGetFullDomainResult},
	"get_jetton_data":               {DecodeGetJettonDataResult},
	"get_last_clean_time":           {DecodeGetLastCleanTimeResult},
	"get_last_fill_up_time":         {DecodeGetLastFillUpTimeResult},
	"get_locker_bill_data":          {DecodeGetLockerBillDataResult},
	"get_locker_data":               {DecodeGetLockerDataResult},
	"get_lockup_data":               {DecodeGetLockupDataResult},
	"get_lp_data":                   {DecodeGetLpData_MegatonResult},
	"get_lp_mining_data":            {DecodeGetLpMiningData_MegatonResult},
	"get_lp_swap_data":              {DecodeGetLpSwapData_MegatonResult},
	"get_member":                    {DecodeGetMember_WhalesNominatorResult},
	"get_members_raw":               {DecodeGetMembersRaw_WhalesNominatorResult},
	"get_mining_data":               {DecodeGetMiningData_MegatonResult},
	"get_multisig_data":             {DecodeGetMultisigDataResult},
	"get_next_admin_address":        {DecodeGetNextAdminAddressResult},
	"get_next_proof_info":           {DecodeGetNextProofInfoResult},
	"get_nft_address_by_index":      {DecodeGetNftAddressByIndexResult},
	"get_nft_api_info":              {DecodeGetNftApiInfoResult},
	"get_nft_content":               {DecodeGetNftContentResult},
	"get_nft_data":                  {DecodeGetNftDataResult},
	"get_nominator_data":            {DecodeGetNominatorDataResult},
	"get_oracle_data":               {DecodeGetOracleDataResult},
	"get_params":                    {DecodeGetParams_WhalesNominatorResult},
	"get_plugin_list":               {DecodeGetPluginListResult},
	"get_pool_data":                 {DecodeGetPoolData_StonfiResult, DecodeGetPoolData_TfResult},
	"get_pool_full_data":            {DecodeGetPoolFullDataResult},
	"get_pool_status":               {DecodeGetPoolStatusResult},
	"get_pow_params":                {DecodeGetPowParamsResult},
	"get_public_key":                {DecodeGetPublicKeyResult},
	"get_reserves":                  {DecodeGetReserves_DedustResult},
	"get_revoked_time":              {DecodeGetRevokedTimeResult},
	"get_router_data":               {DecodeGetRouterData_StonfiResult},
	"get_sale_data":                 {DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult},
	"get_spot_price":                {DecodeGetSpotPriceResult},
	"get_staking_status":            {DecodeGetStakingStatusResult},
	"get_status":                    {DecodeGetStatusResult},
	"get_storage_contract_address":  {DecodeGetStorageContractAddressResult},
	"get_storage_contract_data":     {DecodeGetStorageContractDataResult},
	"get_storage_params":            {DecodeGetStorageParamsResult},
	"get_subscription_data":         {DecodeGetSubscriptionDataResult},
	"get_subwallet_id":              {DecodeGetSubwalletIdResult},
	"get_telemint_auction_config":   {DecodeGetTelemintAuctionConfigResult},
	"get_telemint_auction_state":    {DecodeGetTelemintAuctionStateResult},
	"get_telemint_token_name":       {DecodeGetTelemintTokenNameResult},
	"get_terminal_amm_price":        {DecodeGetTerminalAmmPriceResult},
	"get_timeout":                   {DecodeGetTimeoutResult},
	"get_torrent_hash":              {DecodeGetTorrentHashResult},
	"get_validator_controller_data": {DecodeGetValidatorControllerDataResult},
	"get_vamm_type":                 {DecodeGetVammTypeResult},
	"get_wallet_address":            {DecodeGetWalletAddressResult},
	"get_wallet_data":               {DecodeGetWalletDataResult},
	"get_wallet_params":             {DecodeGetWalletParamsResult},
	"is_active":                     {DecodeIsActiveResult},
	"is_plugin_installed":           {DecodeIsPluginInstalledResult},
	"jetton_wallet_lock_data":       {DecodeJettonWalletLockDataResult},
	"list_nominators":               {DecodeListNominatorsResult},
	"list_votes":                    {DecodeListVotesResult},
	"royalty_params":                {DecodeRoyaltyParamsResult},
	"seqno":                         {DecodeSeqnoResult},
}

var KnownSimpleGetMethods = map[int][]func(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error){
	65971:  {GetReserves},
	66763:  {GetFullDomain},
	69506:  {GetTelemintTokenName},
	69628:  {GetChannelData},
	71463:  {GetTorrentHash},
	72748:  {GetSaleData},
	73490:  {GetLockerData},
	75709:  {GetExecutorVaultsWhitelist},
	78683:  {GetNextAdminAddress},
	78748:  {GetPublicKey},
	80035:  {GetLpData},
	80697:  {GetAuctionInfo},
	80822:  {GetLastCleanTime},
	81467:  {GetSubwalletId},
	81490:  {GetNextProofInfo},
	81689:  {GetPoolData},
	83263:  {GetNftApiInfo},
	84760:  {GetAuthorityAddress},
	85143:  {Seqno},
	85719:  {RoyaltyParams},
	86353:  {GetAmmState},
	86593:  {GetStorageContractData},
	87635:  {GetAmmStatus},
	87675:  {GetSpotPrice},
	87878:  {GetBalances},
	88817:  {GetOracleData},
	89295:  {GetMembersRaw},
	89352:  {GetAsset},
	90228:  {GetEditor},
	91481:  {GetLastFillUpTime},
	92229:  {GetPoolFullData},
	92260:  {GetSubscriptionData},
	96219:  {GetMiningData},
	96263:  {GetExchangeSettings},
	96705:  {GetBillAmount},
	97026:  {GetWalletData},
	97667:  {GetRevokedTime},
	100881: {GetStatus},
	101616: {GetPowParams},
	102351: {GetNftData},
	102491: {GetCollectionData},
	103232: {GetValidatorControllerData},
	104122: {GetLpMiningData},
	104346: {GetStorageParams},
	105070: {GetTimeout},
	105875: {GetAmmContractData},
	106029: {GetJettonData},
	107305: {GetLockupData},
	107307: {GetMultisigData},
	107494: {GetVammType},
	107653: {GetPluginList},
	108868: {GetTerminalAmmPrice},
	111161: {ListNominators},
	115150: {GetParams},
	116242: {GetLpSwapData},
	118188: {GetAssets},
	118274: {GetLockerBillData},
	119378: {GetDomain},
	120146: {GetPoolStatus},
	122058: {IsActive},
	122496: {GetAmmName},
	122498: {GetTelemintAuctionState},
	123928: {GetStakingStatus},
	128085: {GetRouterData},
	128979: {JettonWalletLockData},
	129619: {GetTelemintAuctionConfig},
	130271: {GetWalletParams},
	130309: {ListVotes},
}

var resultTypes = []interface{}{
	&Dnsresolve_RecordsResult{},
	&GetAmmContractDataResult{},
	&GetAmmNameResult{},
	&GetAmmStateResult{},
	&GetAmmStatusResult{},
	&GetAsset_DedustResult{},
	&GetAssets_DedustResult{},
	&GetAuctionInfoResult{},
	&GetAuthorityAddressResult{},
	&GetBalancesResult{},
	&GetBillAddressResult{},
	&GetBillAmountResult{},
	&GetChannelDataResult{},
	&GetCollectionDataResult{},
	&GetDomainResult{},
	&GetEditorResult{},
	&GetExchangeSettingsResult{},
	&GetExecutorVaultsWhitelistResult{},
	&GetFullDomainResult{},
	&GetJettonDataResult{},
	&GetLastCleanTimeResult{},
	&GetLastFillUpTimeResult{},
	&GetLockerBillDataResult{},
	&GetLockerDataResult{},
	&GetLockupDataResult{},
	&GetLpData_MegatonResult{},
	&GetLpMiningData_MegatonResult{},
	&GetLpSwapData_MegatonResult{},
	&GetMember_WhalesNominatorResult{},
	&GetMembersRaw_WhalesNominatorResult{},
	&GetMiningData_MegatonResult{},
	&GetMultisigDataResult{},
	&GetNextAdminAddressResult{},
	&GetNextProofInfoResult{},
	&GetNftAddressByIndexResult{},
	&GetNftApiInfoResult{},
	&GetNftContentResult{},
	&GetNftDataResult{},
	&GetNominatorDataResult{},
	&GetOracleDataResult{},
	&GetParams_WhalesNominatorResult{},
	&GetPluginListResult{},
	&GetPoolData_StonfiResult{},
	&GetPoolData_TfResult{},
	&GetPoolFullDataResult{},
	&GetPoolStatusResult{},
	&GetPowParamsResult{},
	&GetPublicKeyResult{},
	&GetReserves_DedustResult{},
	&GetRevokedTimeResult{},
	&GetRouterData_StonfiResult{},
	&GetSaleData_BasicResult{},
	&GetSaleData_GetgemsAuctionResult{},
	&GetSaleData_GetgemsResult{},
	&GetSpotPriceResult{},
	&GetStakingStatusResult{},
	&GetStatusResult{},
	&GetStorageContractAddressResult{},
	&GetStorageContractDataResult{},
	&GetStorageParamsResult{},
	&GetSubscriptionDataResult{},
	&GetSubwalletIdResult{},
	&GetTelemintAuctionConfigResult{},
	&GetTelemintAuctionStateResult{},
	&GetTelemintTokenNameResult{},
	&GetTerminalAmmPriceResult{},
	&GetTimeoutResult{},
	&GetTorrentHashResult{},
	&GetValidatorControllerDataResult{},
	&GetVammTypeResult{},
	&GetWalletAddressResult{},
	&GetWalletDataResult{},
	&GetWalletParamsResult{},
	&IsActiveResult{},
	&IsPluginInstalledResult{},
	&JettonWalletLockDataResult{},
	&ListNominatorsResult{},
	&ListVotesResult{},
	&RoyaltyParamsResult{},
	&SeqnoResult{},
}

type Executor interface {
	RunSmcMethodByID(ctx context.Context, accountID ton.AccountID, methodID int, params tlb.VmStack) (uint32, tlb.VmStack, error)
}
type Dnsresolve_RecordsResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecordSet
}

func Dnsresolve(ctx context.Context, executor Executor, reqAccountID ton.AccountID, domain []byte, category tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(domain)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: category}
	stack.Put(val)

	// MethodID = 123660 for "dnsresolve" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123660, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeDnsresolve_RecordsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeDnsresolve_RecordsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result Dnsresolve_RecordsResult
	err = stack.Unmarshal(&result)
	return "Dnsresolve_RecordsResult", result, err
}

type GetAmmContractDataResult struct {
	AmmContractData boc.Cell
}

func GetAmmContractData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 105875 for "get_amm_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 105875, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAmmContractDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAmmContractDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAmmContractDataResult
	err = stack.Unmarshal(&result)
	return "GetAmmContractDataResult", result, err
}

type GetAmmNameResult struct {
	VaultAddr tlb.MsgAddress
	AssetId   uint16
}

func GetAmmName(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122496 for "get_amm_name" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122496, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAmmNameResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAmmNameResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 2 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAmmNameResult
	err = stack.Unmarshal(&result)
	return "GetAmmNameResult", result, err
}

type GetAmmStateResult struct {
	QuoteAssetReserve                    uint64
	BaseAssetReserve                     uint64
	QuoteAssetWeight                     uint64
	TotalLongPositionSize                uint64
	TotalShortPositionSize               uint64
	OpenInterestLong                     uint64
	OpenInterestShort                    uint64
	LatestLongCumulativePremiumFraction  int64
	LatestShortCumulativePremiumFraction int64
	NextFundingBlockTimestamp            uint32
}

func GetAmmState(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86353 for "get_amm_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86353, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAmmStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAmmStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 10 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAmmStateResult
	err = stack.Unmarshal(&result)
	return "GetAmmStateResult", result, err
}

type GetAmmStatusResult struct {
	CloseOnly             bool
	Paused                bool
	DirectIncreaseEnabled bool
}

func GetAmmStatus(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 87635 for "get_amm_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 87635, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAmmStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAmmStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAmmStatusResult
	err = stack.Unmarshal(&result)
	return "GetAmmStatusResult", result, err
}

type GetAsset_DedustResult struct {
	Asset DedustAsset
}

func GetAsset(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 89352 for "get_asset" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 89352, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAsset_DedustResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAsset_DedustResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAsset_DedustResult
	err = stack.Unmarshal(&result)
	return "GetAsset_DedustResult", result, err
}

type GetAssets_DedustResult struct {
	Asset0 DedustAsset
	Asset1 DedustAsset
}

func GetAssets(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 118188 for "get_assets" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 118188, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAssets_DedustResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAssets_DedustResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAssets_DedustResult
	err = stack.Unmarshal(&result)
	return "GetAssets_DedustResult", result, err
}

type GetAuctionInfoResult struct {
	MaxBidAddress  tlb.MsgAddress
	MaxBidAmount   uint64
	AuctionEndTime uint64
}

func GetAuctionInfo(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 80697 for "get_auction_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 80697, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAuctionInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAuctionInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAuctionInfoResult
	err = stack.Unmarshal(&result)
	return "GetAuctionInfoResult", result, err
}

type GetAuthorityAddressResult struct {
	Address tlb.MsgAddress
}

func GetAuthorityAddress(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 84760 for "get_authority_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 84760, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAuthorityAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAuthorityAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAuthorityAddressResult
	err = stack.Unmarshal(&result)
	return "GetAuthorityAddressResult", result, err
}

type GetBalancesResult struct {
	TonBalance           int64
	TotalRestrictedValue int64
	TotalLockedValue     int64
}

func GetBalances(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 87878 for "get_balances" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 87878, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetBalancesResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetBalancesResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetBalancesResult
	err = stack.Unmarshal(&result)
	return "GetBalancesResult", result, err
}

type GetBillAddressResult struct {
	BillAddress tlb.MsgAddress
}

func GetBillAddress(ctx context.Context, executor Executor, reqAccountID ton.AccountID, userAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(userAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 130076 for "get_bill_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130076, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetBillAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetBillAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetBillAddressResult
	err = stack.Unmarshal(&result)
	return "GetBillAddressResult", result, err
}

type GetBillAmountResult struct {
	Amount int64
}

func GetBillAmount(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 96705 for "get_bill_amount" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 96705, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetBillAmountResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetBillAmountResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetBillAmountResult
	err = stack.Unmarshal(&result)
	return "GetBillAmountResult", result, err
}

type GetChannelDataResult struct {
	State    int8
	Balances struct {
		A int64
		B int64
	}

	Keys struct {
		A tlb.Bits256
		B tlb.Bits256
	}

	ChannelId     tlb.Uint128
	ClosureConfig struct {
		QuarantinDuration        uint32
		MisbehaviorFine          int64
		ConditionalCloseDuration uint32
	}

	CommittedSeqno struct {
		A uint32
		B uint32
	}

	Quarantine *boc.Cell
	Addresses  struct {
		ExcessFee int64
		AddrA     tlb.MsgAddress
		AddrB     tlb.MsgAddress
	}
}

func GetChannelData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 69628 for "get_channel_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 69628, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetChannelDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetChannelDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 8 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTuple") || (stack[2].SumType != "VmStkTuple") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTuple") || (stack[5].SumType != "VmStkTuple") || (stack[6].SumType != "VmStkSlice" && stack[6].SumType != "VmStkNull") || (stack[7].SumType != "VmStkTuple") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetChannelDataResult
	err = stack.Unmarshal(&result)
	return "GetChannelDataResult", result, err
}

type GetCollectionDataResult struct {
	NextItemIndex     tlb.Int257
	CollectionContent tlb.Any
	OwnerAddress      tlb.MsgAddress
}

func GetCollectionData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102491 for "get_collection_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102491, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetCollectionDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetCollectionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetCollectionDataResult
	err = stack.Unmarshal(&result)
	return "GetCollectionDataResult", result, err
}

type GetDomainResult struct {
	Domain string
}

func GetDomain(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 119378 for "get_domain" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119378, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetDomainResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetDomainResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetDomainResult
	err = stack.Unmarshal(&result)
	return "GetDomainResult", result, err
}

type GetEditorResult struct {
	Editor tlb.MsgAddress
}

func GetEditor(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 90228 for "get_editor" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 90228, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetEditorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetEditorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetEditorResult
	err = stack.Unmarshal(&result)
	return "GetEditorResult", result, err
}

type GetExchangeSettingsResult struct {
	Fee                           uint32
	RolloverFee                   uint32
	FundingPeriod                 uint32
	InitMarginRatio               uint32
	MaintenanceMarginRatio        uint32
	LiquidationFeeRatio           uint32
	PartialLiquidationRatio       uint32
	SpreadLimit                   uint32
	MaxPriceImpact                uint32
	MaxPriceSpread                uint32
	MaxOpenNotional               uint64
	FeeToStakersPercent           uint32
	FundingMode                   uint32
	MinPartialLiquidationNotional uint64
	MinInitMarginRatio            uint32
	ExecutorFee                   int32
	ClosePositionTimeDelta        int32
	MaxUnrealizedPnl              int32
	DirectIncreaseEnabled         bool
	DirectCloseEnabled            bool
	ExecutorsWhitelist            boc.Cell
	LowFundingFnA                 int32
	LowFundingFnB                 int32
	HighFundingFnA                int32
	HighFundingFnB                int32
	InflectionPoint               int32
}

func GetExchangeSettings(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 96263 for "get_exchange_settings" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 96263, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetExchangeSettingsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetExchangeSettingsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 26 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") || (stack[11].SumType != "VmStkTinyInt" && stack[11].SumType != "VmStkInt") || (stack[12].SumType != "VmStkTinyInt" && stack[12].SumType != "VmStkInt") || (stack[13].SumType != "VmStkTinyInt" && stack[13].SumType != "VmStkInt") || (stack[14].SumType != "VmStkTinyInt" && stack[14].SumType != "VmStkInt") || (stack[15].SumType != "VmStkTinyInt" && stack[15].SumType != "VmStkInt") || (stack[16].SumType != "VmStkTinyInt" && stack[16].SumType != "VmStkInt") || (stack[17].SumType != "VmStkTinyInt" && stack[17].SumType != "VmStkInt") || (stack[18].SumType != "VmStkTinyInt" && stack[18].SumType != "VmStkInt") || (stack[19].SumType != "VmStkTinyInt" && stack[19].SumType != "VmStkInt") || (stack[20].SumType != "VmStkCell") || (stack[21].SumType != "VmStkTinyInt" && stack[21].SumType != "VmStkInt") || (stack[22].SumType != "VmStkTinyInt" && stack[22].SumType != "VmStkInt") || (stack[23].SumType != "VmStkTinyInt" && stack[23].SumType != "VmStkInt") || (stack[24].SumType != "VmStkTinyInt" && stack[24].SumType != "VmStkInt") || (stack[25].SumType != "VmStkTinyInt" && stack[25].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetExchangeSettingsResult
	err = stack.Unmarshal(&result)
	return "GetExchangeSettingsResult", result, err
}

type GetExecutorVaultsWhitelistResult struct {
	BalancesDict boc.Cell
}

func GetExecutorVaultsWhitelist(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 75709 for "get_executor_vaults_whitelist" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 75709, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetExecutorVaultsWhitelistResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetExecutorVaultsWhitelistResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetExecutorVaultsWhitelistResult
	err = stack.Unmarshal(&result)
	return "GetExecutorVaultsWhitelistResult", result, err
}

type GetFullDomainResult struct {
	Domain string
}

func GetFullDomain(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 66763 for "get_full_domain" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 66763, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetFullDomainResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetFullDomainResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetFullDomainResult
	err = stack.Unmarshal(&result)
	return "GetFullDomainResult", result, err
}

type GetJettonDataResult struct {
	TotalSupply      tlb.Int257
	Mintable         bool
	AdminAddress     tlb.MsgAddress
	JettonContent    tlb.Any
	JettonWalletCode tlb.Any
}

func GetJettonData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106029 for "get_jetton_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106029, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetJettonDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetJettonDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetJettonDataResult
	err = stack.Unmarshal(&result)
	return "GetJettonDataResult", result, err
}

type GetLastCleanTimeResult struct {
	Timestamp uint64
}

func GetLastCleanTime(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 80822 for "get_last_clean_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 80822, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLastCleanTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLastCleanTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLastCleanTimeResult
	err = stack.Unmarshal(&result)
	return "GetLastCleanTimeResult", result, err
}

type GetLastFillUpTimeResult struct {
	LastFillUpTime int64
}

func GetLastFillUpTime(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 91481 for "get_last_fill_up_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 91481, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLastFillUpTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLastFillUpTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLastFillUpTimeResult
	err = stack.Unmarshal(&result)
	return "GetLastFillUpTimeResult", result, err
}

type GetLockerBillDataResult struct {
	LockerAddress     tlb.MsgAddress
	TotalCoinsDeposit uint64
	UserAddress       tlb.MsgAddress
	LastWithdrawTime  uint32
}

func GetLockerBillData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 118274 for "get_locker_bill_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 118274, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLockerBillDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLockerBillDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 4 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLockerBillDataResult
	err = stack.Unmarshal(&result)
	return "GetLockerBillDataResult", result, err
}

type GetLockerDataResult struct {
	TotalCoinsLocked     uint64
	TotalReward          uint64
	DepositsEndTime      uint32
	VestingStartTime     uint32
	VestingTotalDuration uint32
	UnlockPeriod         uint32
}

func GetLockerData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 73490 for "get_locker_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 73490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLockerDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLockerDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLockerDataResult
	err = stack.Unmarshal(&result)
	return "GetLockerDataResult", result, err
}

type GetLockupDataResult struct {
	StartTime     int64
	TotalDuration int64
	UnlockPeriod  int64
	CliffDiration int64
	TotalAmount   int64
	AllowElector  int64
}

func GetLockupData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107305 for "get_lockup_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107305, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLockupDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLockupDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLockupDataResult
	err = stack.Unmarshal(&result)
	return "GetLockupDataResult", result, err
}

type GetLpData_MegatonResult struct {
	PoolCount      uint64
	JettonPairToLp tlb.Any
	LpToJettonPair tlb.Any
}

func GetLpData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 80035 for "get_lp_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 80035, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLpData_MegatonResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLpData_MegatonResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") || (stack[2].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLpData_MegatonResult
	err = stack.Unmarshal(&result)
	return "GetLpData_MegatonResult", result, err
}

type GetLpMiningData_MegatonResult struct {
	MiningAmount   uint64
	DatetimeAmount uint64
	MinableTime    uint64
	HalfLife       uint64
	LastIndex      uint64
	LastMined      uint64
	MiningRateCell tlb.Any
}

func GetLpMiningData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104122 for "get_lp_mining_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104122, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLpMiningData_MegatonResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLpMiningData_MegatonResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLpMiningData_MegatonResult
	err = stack.Unmarshal(&result)
	return "GetLpMiningData_MegatonResult", result, err
}

type GetLpSwapData_MegatonResult struct {
	SwapFee               uint64
	MinAmount             uint64
	RouterAddress         tlb.MsgAddress
	JettonAAddress        tlb.MsgAddress
	JettonAWalletAddress  tlb.MsgAddress
	JettonABalance        tlb.Int257
	JettonAPendingBalance tlb.Int257
	JettonBAddress        tlb.MsgAddress
	JettonBWalletAddress  tlb.MsgAddress
	JettonBBalance        tlb.Int257
	JettonBPendingBalance tlb.Int257
}

func GetLpSwapData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 116242 for "get_lp_swap_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 116242, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLpSwapData_MegatonResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLpSwapData_MegatonResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkSlice") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLpSwapData_MegatonResult
	err = stack.Unmarshal(&result)
	return "GetLpSwapData_MegatonResult", result, err
}

type GetMember_WhalesNominatorResult struct {
	MemberBalance         int64
	MemberPendingDeposit  int64
	MemberPendingWithdraw int64
	MemberWithdraw        int64
}

func GetMember(ctx context.Context, executor Executor, reqAccountID ton.AccountID, member tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(member)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 70558 for "get_member" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 70558, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMember_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMember_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMember_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMember_WhalesNominatorResult", result, err
}

type GetMembersRaw_WhalesNominatorResult struct {
	Members WhalesNominatorsMembersList
}

func GetMembersRaw(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 89295 for "get_members_raw" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 89295, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMembersRaw_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMembersRaw_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMembersRaw_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMembersRaw_WhalesNominatorResult", result, err
}

type GetMiningData_MegatonResult struct {
	TotalMiningAmount  uint64
	TotalMiningRate    uint64
	MiningAmountPerSec uint64
	HalfLife           uint64
	TotalReward        uint64
	Unknown            uint64
}

func GetMiningData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 96219 for "get_mining_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 96219, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMiningData_MegatonResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMiningData_MegatonResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMiningData_MegatonResult
	err = stack.Unmarshal(&result)
	return "GetMiningData_MegatonResult", result, err
}

type GetMultisigDataResult struct {
	Seqno     tlb.Int257
	Threshold uint8
	Signers   MultisigSignersList
	Proposers *MultisigProposersList
}

func GetMultisigData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107307 for "get_multisig_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107307, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMultisigDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMultisigDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkCell") || (stack[3].SumType != "VmStkCell" && stack[3].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMultisigDataResult
	err = stack.Unmarshal(&result)
	return "GetMultisigDataResult", result, err
}

type GetNextAdminAddressResult struct {
	NextAdminAddress tlb.MsgAddress
}

func GetNextAdminAddress(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78683 for "get_next_admin_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78683, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNextAdminAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNextAdminAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNextAdminAddressResult
	err = stack.Unmarshal(&result)
	return "GetNextAdminAddressResult", result, err
}

type GetNextProofInfoResult struct {
	NextProof     uint64
	LastProofTime uint32
	MaxSpan       uint32
}

func GetNextProofInfo(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81490 for "get_next_proof_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNextProofInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNextProofInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNextProofInfoResult
	err = stack.Unmarshal(&result)
	return "GetNextProofInfoResult", result, err
}

type GetNftAddressByIndexResult struct {
	Address tlb.MsgAddress
}

func GetNftAddressByIndex(ctx context.Context, executor Executor, reqAccountID ton.AccountID, index tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)

	// MethodID = 92067 for "get_nft_address_by_index" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92067, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftAddressByIndexResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftAddressByIndexResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftAddressByIndexResult
	err = stack.Unmarshal(&result)
	return "GetNftAddressByIndexResult", result, err
}

type GetNftApiInfoResult struct {
	Version uint32
	Uri     tlb.Text
}

func GetNftApiInfo(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 83263 for "get_nft_api_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 83263, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftApiInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftApiInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 2 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftApiInfoResult
	err = stack.Unmarshal(&result)
	return "GetNftApiInfoResult", result, err
}

type GetNftContentResult struct {
	Content tlb.FullContent
}

func GetNftContent(ctx context.Context, executor Executor, reqAccountID ton.AccountID, index tlb.Int257, individualContent tlb.Any) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCell(individualContent)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 68445 for "get_nft_content" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 68445, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftContentResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftContentResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftContentResult
	err = stack.Unmarshal(&result)
	return "GetNftContentResult", result, err
}

type GetNftDataResult struct {
	Init              bool
	Index             tlb.Int257
	CollectionAddress tlb.MsgAddress
	OwnerAddress      tlb.MsgAddress
	IndividualContent tlb.Any
}

func GetNftData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102351 for "get_nft_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102351, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftDataResult
	err = stack.Unmarshal(&result)
	return "GetNftDataResult", result, err
}

type GetNominatorDataResult struct {
	Amount               uint64
	PendingDepositAmount uint64
	WithdrawFound        bool
}

func GetNominatorData(ctx context.Context, executor Executor, reqAccountID ton.AccountID, address tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: address}
	stack.Put(val)

	// MethodID = 112473 for "get_nominator_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 112473, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNominatorDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNominatorDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNominatorDataResult
	err = stack.Unmarshal(&result)
	return "GetNominatorDataResult", result, err
}

type GetOracleDataResult struct {
	OracleLastPrice       uint64
	OracleLastSpread      uint64
	OracleLastTimestamp   uint32
	OracleMaxDeviation    uint64
	OracleValidityPeriod  uint32
	OraclePublicKeysCount uint8
	OraclePublicKeysRef   boc.Cell
}

func GetOracleData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 88817 for "get_oracle_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 88817, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetOracleDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetOracleDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 7 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetOracleDataResult
	err = stack.Unmarshal(&result)
	return "GetOracleDataResult", result, err
}

type GetParams_WhalesNominatorResult struct {
	Enabled        bool
	UpdatesEnables bool
	MinStake       int64
	DepositFee     int64
	WithdrawFee    int64
	PoolFee        int64
	ReceiptPrice   int64
}

func GetParams(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 115150 for "get_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 115150, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetParams_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetParams_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetParams_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetParams_WhalesNominatorResult", result, err
}

type GetPluginListResult struct {
	Plugins []struct {
		Workchain int32
		Address   tlb.Bits256
	}
}

func GetPluginList(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107653 for "get_plugin_list" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107653, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPluginListResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPluginListResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPluginListResult
	err = stack.Unmarshal(&result)
	return "GetPluginListResult", result, err
}

type GetPoolData_StonfiResult struct {
	Reserve0                   tlb.Int257
	Reserve1                   tlb.Int257
	Token0Address              tlb.MsgAddress
	Token1Address              tlb.MsgAddress
	LpFee                      uint8
	ProtocolFee                uint8
	RefFee                     uint8
	ProtocolFeeAddress         tlb.MsgAddress
	CollectedToken0ProtocolFee tlb.Int257
	CollectedToken1ProtocolFee tlb.Int257
}

type GetPoolData_TfResult struct {
	State                    int8
	NominatorsCount          uint32
	StakeAmountSent          int64
	ValidatorAmount          int64
	ValidatorAddress         tlb.Bits256
	ValidatorRewardShare     uint32
	MaxNominatorsCount       uint32
	MinValidatorStake        int64
	MinNominatorStake        int64
	Nominators               tlb.Any
	WithdrawRequests         *AccountLists
	StakeAt                  uint32
	SavedValidatorSetHash    tlb.Bits256
	ValidatorSetChangesCount uint32
	ValidatorSetChangeTime   uint32
	StakeHeldFor             uint32
	ConfigProposalVotings    []struct {
	}
}

func GetPoolData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81689 for "get_pool_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81689, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolData_StonfiResult, DecodeGetPoolData_TfResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolData_StonfiResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 10 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolData_StonfiResult
	err = stack.Unmarshal(&result)
	return "GetPoolData_StonfiResult", result, err
}

func DecodeGetPoolData_TfResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 17 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkCell") || (stack[10].SumType != "VmStkCell" && stack[10].SumType != "VmStkNull") || (stack[11].SumType != "VmStkTinyInt" && stack[11].SumType != "VmStkInt") || (stack[12].SumType != "VmStkTinyInt" && stack[12].SumType != "VmStkInt") || (stack[13].SumType != "VmStkTinyInt" && stack[13].SumType != "VmStkInt") || (stack[14].SumType != "VmStkTinyInt" && stack[14].SumType != "VmStkInt") || (stack[15].SumType != "VmStkTinyInt" && stack[15].SumType != "VmStkInt") || (stack[16].SumType != "VmStkTuple" && stack[16].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolData_TfResult
	err = stack.Unmarshal(&result)
	return "GetPoolData_TfResult", result, err
}

type GetPoolFullDataResult struct {
	State                        int32
	Halted                       bool
	TotalBalance                 int64
	InterestRate                 int32
	OptimisticDepositWithdrawals int64
	DepositsOpen                 bool
	SavedValidatorSetHash        tlb.Bits256
	PrevRoundBorrowers           struct {
		BorrowersDict   *boc.Cell
		RoundId         int32
		ActiveBorrowers int32
		Borrowed        int64
		Expected        int64
		Retured         int64
		Profit          int64
	}

	CurrentRoundBorrowers struct {
		BorrowersDict   *boc.Cell
		RoundId         int32
		ActiveBorrowers int32
		Borrowed        int64
		Expected        int64
		Retured         int64
		Profit          int64
	}

	MinLoanPerValidator    int64
	MaxLoanPerValidator    int64
	GovernanceFee          int32
	JettonMinter           tlb.MsgAddress
	Supply                 int64
	DepositPayout          *tlb.MsgAddress
	RequestedForDeposit    int64
	WithdrawalPayout       *tlb.MsgAddress
	RequestedForWithdrawal int64
	Sudoer                 *tlb.MsgAddress
	SudoerSetAt            int32
	Governor               *tlb.MsgAddress
	GovernorUpdateAfter    int64
	InterestManager        *tlb.MsgAddress
	Halter                 *tlb.MsgAddress
	Approver               *tlb.MsgAddress
	ControllerCode         boc.Cell
	PoolJettonWalletCode   boc.Cell
	PayoutMinterCode       boc.Cell
	ProjectedBalance       int64
	ProjectedSupply        int64
}

func GetPoolFullData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 92229 for "get_pool_full_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92229, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolFullDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolFullDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 30 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTuple") || (stack[8].SumType != "VmStkTuple") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") || (stack[11].SumType != "VmStkTinyInt" && stack[11].SumType != "VmStkInt") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkTinyInt" && stack[13].SumType != "VmStkInt") || (stack[14].SumType != "VmStkSlice" && stack[14].SumType != "VmStkNull") || (stack[15].SumType != "VmStkTinyInt" && stack[15].SumType != "VmStkInt") || (stack[16].SumType != "VmStkSlice" && stack[16].SumType != "VmStkNull") || (stack[17].SumType != "VmStkTinyInt" && stack[17].SumType != "VmStkInt") || (stack[18].SumType != "VmStkSlice" && stack[18].SumType != "VmStkNull") || (stack[19].SumType != "VmStkTinyInt" && stack[19].SumType != "VmStkInt") || (stack[20].SumType != "VmStkSlice" && stack[20].SumType != "VmStkNull") || (stack[21].SumType != "VmStkTinyInt" && stack[21].SumType != "VmStkInt") || (stack[22].SumType != "VmStkSlice" && stack[22].SumType != "VmStkNull") || (stack[23].SumType != "VmStkSlice" && stack[23].SumType != "VmStkNull") || (stack[24].SumType != "VmStkSlice" && stack[24].SumType != "VmStkNull") || (stack[25].SumType != "VmStkCell") || (stack[26].SumType != "VmStkCell") || (stack[27].SumType != "VmStkCell") || (stack[28].SumType != "VmStkTinyInt" && stack[28].SumType != "VmStkInt") || (stack[29].SumType != "VmStkTinyInt" && stack[29].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolFullDataResult
	err = stack.Unmarshal(&result)
	return "GetPoolFullDataResult", result, err
}

type GetPoolStatusResult struct {
	Balance                int64
	BalanceSent            int64
	BalancePendingDeposits int64
	BalancePendingWithdraw int64
	BalanceWithdraw        int64
}

func GetPoolStatus(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 120146 for "get_pool_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 120146, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolStatusResult
	err = stack.Unmarshal(&result)
	return "GetPoolStatusResult", result, err
}

type GetPowParamsResult struct {
	Seed          tlb.Uint128
	PowComplexity tlb.Int256
	Amount        uint64
	Interval      uint32
}

func GetPowParams(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 101616 for "get_pow_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 101616, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPowParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPowParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPowParamsResult
	err = stack.Unmarshal(&result)
	return "GetPowParamsResult", result, err
}

type GetPublicKeyResult struct {
	PublicKey tlb.Int257
}

func GetPublicKey(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78748 for "get_public_key" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPublicKeyResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPublicKeyResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPublicKeyResult
	err = stack.Unmarshal(&result)
	return "GetPublicKeyResult", result, err
}

type GetReserves_DedustResult struct {
	Reserve0 tlb.Int257
	Reserve1 tlb.Int257
}

func GetReserves(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 65971 for "get_reserves" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 65971, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetReserves_DedustResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetReserves_DedustResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetReserves_DedustResult
	err = stack.Unmarshal(&result)
	return "GetReserves_DedustResult", result, err
}

type GetRevokedTimeResult struct {
	Time uint64
}

func GetRevokedTime(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97667 for "get_revoked_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97667, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetRevokedTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetRevokedTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetRevokedTimeResult
	err = stack.Unmarshal(&result)
	return "GetRevokedTimeResult", result, err
}

type GetRouterData_StonfiResult struct {
	IsLocked           bool
	AdminAddress       tlb.MsgAddress
	TempUpgrade        tlb.Any
	PoolCode           tlb.Any
	JettonLpWalletCode tlb.Any
	LpAccountCode      tlb.Any
}

func GetRouterData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 128085 for "get_router_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 128085, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetRouterData_StonfiResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetRouterData_StonfiResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkCell") || (stack[3].SumType != "VmStkCell") || (stack[4].SumType != "VmStkCell") || (stack[5].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetRouterData_StonfiResult
	err = stack.Unmarshal(&result)
	return "GetRouterData_StonfiResult", result, err
}

type GetSaleData_BasicResult struct {
	Marketplace    tlb.MsgAddress
	Nft            tlb.MsgAddress
	Owner          tlb.MsgAddress
	FullPrice      tlb.Int257
	MarketFee      uint64
	RoyaltyAddress tlb.MsgAddress
	RoyaltyAmount  uint64
}

type GetSaleData_GetgemsAuctionResult struct {
	Magic            uint64
	End              bool
	EndTime          uint32
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	LastBid          uint64
	LastMember       tlb.MsgAddress
	MinStep          uint64
	MarketFeeAddress tlb.MsgAddress
	MpFeeFactor      uint32
	MpFeeBase        uint32
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyFeeFactor uint32
	RoyaltyFeeBase   uint32
	MaxBid           uint64
	MinBid           uint64
	CreatedAt        uint32
	LastBidAt        uint32
	IsCanceled       bool
}

type GetSaleData_GetgemsResult struct {
	Magic            uint64
	IsComplete       bool
	CreatedAt        uint64
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	FullPrice        tlb.Int257
	MarketFeeAddress tlb.MsgAddress
	MarketFee        uint64
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyAmount    uint64
}

func GetSaleData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSaleData_BasicResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_BasicResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_BasicResult", result, err
}

func DecodeGetSaleData_GetgemsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsResult", result, err
}

func DecodeGetSaleData_GetgemsAuctionResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 20 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") || (stack[11].SumType != "VmStkTinyInt" && stack[11].SumType != "VmStkInt") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkTinyInt" && stack[13].SumType != "VmStkInt") || (stack[14].SumType != "VmStkTinyInt" && stack[14].SumType != "VmStkInt") || (stack[15].SumType != "VmStkTinyInt" && stack[15].SumType != "VmStkInt") || (stack[16].SumType != "VmStkTinyInt" && stack[16].SumType != "VmStkInt") || (stack[17].SumType != "VmStkTinyInt" && stack[17].SumType != "VmStkInt") || (stack[18].SumType != "VmStkTinyInt" && stack[18].SumType != "VmStkInt") || (stack[19].SumType != "VmStkTinyInt" && stack[19].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsAuctionResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsAuctionResult", result, err
}

type GetSpotPriceResult struct {
	SpotPrice tlb.Grams
}

func GetSpotPrice(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 87675 for "get_spot_price" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 87675, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSpotPriceResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSpotPriceResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSpotPriceResult
	err = stack.Unmarshal(&result)
	return "GetSpotPriceResult", result, err
}

type GetStakingStatusResult struct {
	StakeAt             uint32
	StakeUntil          uint32
	StakeSent           uint64
	QuerySent           bool
	CouldUnlock         bool
	Locked              bool
	ProxyStakeLockFinal bool
}

func GetStakingStatus(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 123928 for "get_staking_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123928, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStakingStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStakingStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStakingStatusResult
	err = stack.Unmarshal(&result)
	return "GetStakingStatusResult", result, err
}

type GetStatusResult struct {
	Status uint8
}

func GetStatus(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 100881 for "get_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 100881, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStatusResult
	err = stack.Unmarshal(&result)
	return "GetStatusResult", result, err
}

type GetStorageContractAddressResult struct {
	StorageContractAddress tlb.MsgAddress
}

func GetStorageContractAddress(ctx context.Context, executor Executor, reqAccountID ton.AccountID, merkleHash tlb.Int257, fileSize uint64, client tlb.MsgAddress, torrentHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: merkleHash}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(fileSize)}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCellSlice(client)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: torrentHash}
	stack.Put(val)

	// MethodID = 119729 for "get_storage_contract_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119729, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractAddressResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractAddressResult", result, err
}

type GetStorageContractDataResult struct {
	Active        bool
	Balance       uint64
	Provider      tlb.MsgAddress
	MerkleHash    tlb.Int257
	FileSize      uint64
	NextProof     uint64
	RatePerMbDay  uint64
	MaxSpan       uint32
	LastProofTime uint32
	Client        tlb.MsgAddress
	TorrentHash   tlb.Int257
}

func GetStorageContractData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86593 for "get_storage_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86593, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 11 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractDataResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractDataResult", result, err
}

type GetStorageParamsResult struct {
	AcceptNewContracts bool
	RatePerMbDay       uint64
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

func GetStorageParams(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104346 for "get_storage_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104346, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageParamsResult
	err = stack.Unmarshal(&result)
	return "GetStorageParamsResult", result, err
}

type GetSubscriptionDataResult struct {
	Wallet struct {
		Workchain uint32
		Address   tlb.Bits256
	}

	Beneficiary struct {
		Workchain uint32
		Address   tlb.Bits256
	}

	Amount          uint64
	Period          uint64
	StartTime       uint64
	Timeout         uint64
	LastPaymentTime uint64
	LastRequestTime uint64
	FailedAttempts  uint32
	SubscriptionId  uint64
}

func GetSubscriptionData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 92260 for "get_subscription_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92260, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSubscriptionDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSubscriptionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 10 || (stack[0].SumType != "VmStkTuple") || (stack[1].SumType != "VmStkTuple") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSubscriptionDataResult
	err = stack.Unmarshal(&result)
	return "GetSubscriptionDataResult", result, err
}

type GetSubwalletIdResult struct {
	SubwalletId uint32
}

func GetSubwalletId(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81467 for "get_subwallet_id" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81467, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSubwalletIdResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSubwalletIdResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSubwalletIdResult
	err = stack.Unmarshal(&result)
	return "GetSubwalletIdResult", result, err
}

type GetTelemintAuctionConfigResult struct {
	Beneficiar    tlb.MsgAddress
	InitialMinBid int64
	MaxBid        int64
	MinBidStep    int64
	MinExtendTime int64
	Duration      int64
}

func GetTelemintAuctionConfig(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 129619 for "get_telemint_auction_config" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 129619, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionConfigResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionConfigResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionConfigResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionConfigResult", result, err
}

type GetTelemintAuctionStateResult struct {
	Bidder  tlb.MsgAddress
	Bid     int64
	BidTs   int64
	MinBid  int64
	EndTime int64
}

func GetTelemintAuctionState(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122498 for "get_telemint_auction_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122498, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionStateResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionStateResult", result, err
}

type GetTelemintTokenNameResult struct {
	Username tlb.Text
}

func GetTelemintTokenName(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 69506 for "get_telemint_token_name" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 69506, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintTokenNameResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintTokenNameResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintTokenNameResult
	err = stack.Unmarshal(&result)
	return "GetTelemintTokenNameResult", result, err
}

type GetTerminalAmmPriceResult struct {
	BalancesDict tlb.Any
}

func GetTerminalAmmPrice(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 108868 for "get_terminal_amm_price" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 108868, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTerminalAmmPriceResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTerminalAmmPriceResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTerminalAmmPriceResult
	err = stack.Unmarshal(&result)
	return "GetTerminalAmmPriceResult", result, err
}

type GetTimeoutResult struct {
	Timeout uint32
}

func GetTimeout(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 105070 for "get_timeout" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 105070, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTimeoutResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTimeoutResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTimeoutResult
	err = stack.Unmarshal(&result)
	return "GetTimeoutResult", result, err
}

type GetTorrentHashResult struct {
	TorrentHash tlb.Int257
}

func GetTorrentHash(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 71463 for "get_torrent_hash" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 71463, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTorrentHashResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTorrentHashResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTorrentHashResult
	err = stack.Unmarshal(&result)
	return "GetTorrentHashResult", result, err
}

type GetValidatorControllerDataResult struct {
	State                    int32
	Halted                   bool
	Approved                 bool
	StakeAmountSent          int64
	StakeAt                  uint32
	SavedValidatorSetHash    tlb.Bits256
	ValidatorSetChangesCount int32
	ValidatorSetChangeTime   uint32
	StakeHeldFor             uint32
	BorrowedAmount           int64
	BorrowingTime            uint32
	Validator                tlb.MsgAddress
	Pool                     tlb.MsgAddress
	Sudoer                   tlb.MsgAddress
}

func GetValidatorControllerData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 103232 for "get_validator_controller_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103232, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetValidatorControllerDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetValidatorControllerDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 14 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") || (stack[11].SumType != "VmStkSlice") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetValidatorControllerDataResult
	err = stack.Unmarshal(&result)
	return "GetValidatorControllerDataResult", result, err
}

type GetVammTypeResult struct {
	VammType uint32
}

func GetVammType(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107494 for "get_vamm_type" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107494, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetVammTypeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetVammTypeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetVammTypeResult
	err = stack.Unmarshal(&result)
	return "GetVammTypeResult", result, err
}

type GetWalletAddressResult struct {
	JettonWalletAddress tlb.MsgAddress
}

func GetWalletAddress(ctx context.Context, executor Executor, reqAccountID ton.AccountID, ownerAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(ownerAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 103289 for "get_wallet_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103289, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletAddressResult
	err = stack.Unmarshal(&result)
	return "GetWalletAddressResult", result, err
}

type GetWalletDataResult struct {
	Balance          tlb.Int257
	Owner            tlb.MsgAddress
	Jetton           tlb.MsgAddress
	JettonWalletCode tlb.Any
}

func GetWalletData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97026 for "get_wallet_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97026, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletDataResult
	err = stack.Unmarshal(&result)
	return "GetWalletDataResult", result, err
}

type GetWalletParamsResult struct {
	Seqno     uint32
	Subwallet uint32
	PublicKey tlb.Int257
}

func GetWalletParams(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130271 for "get_wallet_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130271, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletParamsResult
	err = stack.Unmarshal(&result)
	return "GetWalletParamsResult", result, err
}

type IsActiveResult struct {
	IsActive bool
}

func IsActive(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122058 for "is_active" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122058, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsActiveResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsActiveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsActiveResult
	err = stack.Unmarshal(&result)
	return "IsActiveResult", result, err
}

type IsPluginInstalledResult struct {
	Success bool
}

func IsPluginInstalled(ctx context.Context, executor Executor, reqAccountID ton.AccountID, workchain int32, addrHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(workchain)}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: addrHash}
	stack.Put(val)

	// MethodID = 76407 for "is_plugin_installed" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 76407, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsPluginInstalledResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsPluginInstalledResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsPluginInstalledResult
	err = stack.Unmarshal(&result)
	return "IsPluginInstalledResult", result, err
}

type JettonWalletLockDataResult struct {
	FullBalance          tlb.Int257
	IndividualUnlockTime uint32
}

func JettonWalletLockData(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 128979 for "jetton_wallet_lock_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 128979, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeJettonWalletLockDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeJettonWalletLockDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 2 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result JettonWalletLockDataResult
	err = stack.Unmarshal(&result)
	return "JettonWalletLockDataResult", result, err
}

type ListNominatorsResult struct {
	Nominators []struct {
		Address              tlb.Bits256
		Amount               uint64
		PendingDepositAmount uint64
		WithdrawRequested    bool
	}
}

func ListNominators(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 111161 for "list_nominators" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 111161, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListNominatorsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListNominatorsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListNominatorsResult
	err = stack.Unmarshal(&result)
	return "ListNominatorsResult", result, err
}

type ListVotesResult struct {
	Votes []struct {
		ProposalHash   tlb.Bits256
		VoteCreateTime uint32
	}
}

func ListVotes(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130309 for "list_votes" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130309, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListVotesResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListVotesResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListVotesResult
	err = stack.Unmarshal(&result)
	return "ListVotesResult", result, err
}

type RoyaltyParamsResult struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

func RoyaltyParams(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85719 for "royalty_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85719, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeRoyaltyParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeRoyaltyParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result RoyaltyParamsResult
	err = stack.Unmarshal(&result)
	return "RoyaltyParamsResult", result, err
}

type SeqnoResult struct {
	State uint32
}

func Seqno(ctx context.Context, executor Executor, reqAccountID ton.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85143 for "seqno" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85143, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeSeqnoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeSeqnoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result SeqnoResult
	err = stack.Unmarshal(&result)
	return "SeqnoResult", result, err
}
