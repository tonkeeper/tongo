package liteclient
// Code autogenerated. DO NOT EDIT. 

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"github.com/tonkeeper/tongo/tl"
	"io"
)

type TonNodeBlockIdC struct {
	Workchain int32
	Shard     uint64
	Seqno     uint32
}

func (t TonNodeBlockIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeBlockIdExtC struct {
	Workchain int32
	Shard     uint64
	Seqno     uint32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeBlockIdExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockIdExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeZeroStateIdExtC struct {
	Workchain int32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeZeroStateIdExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeZeroStateIdExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeShardPublicOverlayIdC struct {
	Workchain         int32
	Shard             uint64
	ZeroStateFileHash tl.Int256
}

func (t TonNodeShardPublicOverlayIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ZeroStateFileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeShardPublicOverlayIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ZeroStateFileHash)
	if err != nil {
		return err
	}
	return nil
}

type AdnlMessage struct {
	tl.SumType
	AdnlMessageQuery struct {
		QueryId tl.Int256
		Query   []byte
	}
	AdnlMessageAnswer struct {
		QueryId tl.Int256
		Answer  []byte
	}
}

func (t AdnlMessage) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "AdnlMessageQuery":
		b, err = tl.Marshal(uint32(0xb48bf97a))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageQuery.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageQuery.Query)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "AdnlMessageAnswer":
		b, err = tl.Marshal(uint32(0xfac8416))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageAnswer.Answer)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *AdnlMessage) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xb48bf97a:
		t.SumType = "AdnlMessageQuery"
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.Query)
		if err != nil {
			return err
		}
	case 0xfac8416:
		t.SumType = "AdnlMessageAnswer"
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.Answer)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerErrorC struct {
	Code    uint32
	Message string
}

func (t LiteServerErrorC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Code)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Message)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerErrorC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Code)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Message)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountIdC struct {
	Workchain int32
	Id        tl.Int256
}

func (t LiteServerAccountIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryEntryC struct {
	Hash tl.Int256
	Data []byte
}

func (t LiteServerLibraryEntryC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryEntryC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Hash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfoC struct {
	Last          TonNodeBlockIdExtC
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExtC
}

func (t LiteServerMasterchainInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfoExtC struct {
	Mode          uint32
	Version       uint32
	Capabilities  uint64
	Last          TonNodeBlockIdExtC
	LastUtime     uint32
	Now           uint32
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExtC
}

func (t LiteServerMasterchainInfoExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.LastUtime)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfoExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.LastUtime)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerCurrentTimeC struct {
	Now uint32
}

func (t LiteServerCurrentTimeC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerCurrentTimeC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerVersionC struct {
	Mode         uint32
	Version      uint32
	Capabilities uint64
	Now          uint32
}

func (t LiteServerVersionC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerVersionC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockDataC struct {
	Id   TonNodeBlockIdExtC
	Data []byte
}

func (t LiteServerBlockDataC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockDataC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockStateC struct {
	Id       TonNodeBlockIdExtC
	RootHash tl.Int256
	FileHash tl.Int256
	Data     []byte
}

func (t LiteServerBlockStateC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockStateC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockHeaderC struct {
	Id          TonNodeBlockIdExtC
	Mode        uint32
	HeaderProof []byte
}

func (t LiteServerBlockHeaderC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.HeaderProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockHeaderC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.HeaderProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSendMsgStatusC struct {
	Status uint32
}

func (t LiteServerSendMsgStatusC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Status)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSendMsgStatusC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Status)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountStateC struct {
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	Proof      []byte
	State      []byte
}

func (t LiteServerAccountStateC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.State)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountStateC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.State)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerRunMethodResultC struct {
	Mode       uint32
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	Proof      []byte
	StateProof []byte
	InitC7     []byte
	LibExtras  []byte
	ExitCode   uint32
	Result     []byte
}

func (t LiteServerRunMethodResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.ShardProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>3)&1 == 1 {
		b, err = tl.Marshal(t.InitC7)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>4)&1 == 1 {
		b, err = tl.Marshal(t.LibExtras)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	b, err = tl.Marshal(t.ExitCode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Result)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerRunMethodResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempShardProof []byte
		err = tl.Unmarshal(r, &tempShardProof)
		if err != nil {
			return err
		}
		t.ShardProof = tempShardProof
	}
	if (t.Mode>>0)&1 == 1 {
		var tempProof []byte
		err = tl.Unmarshal(r, &tempProof)
		if err != nil {
			return err
		}
		t.Proof = tempProof
	}
	if (t.Mode>>1)&1 == 1 {
		var tempStateProof []byte
		err = tl.Unmarshal(r, &tempStateProof)
		if err != nil {
			return err
		}
		t.StateProof = tempStateProof
	}
	if (t.Mode>>3)&1 == 1 {
		var tempInitC7 []byte
		err = tl.Unmarshal(r, &tempInitC7)
		if err != nil {
			return err
		}
		t.InitC7 = tempInitC7
	}
	if (t.Mode>>4)&1 == 1 {
		var tempLibExtras []byte
		err = tl.Unmarshal(r, &tempLibExtras)
		if err != nil {
			return err
		}
		t.LibExtras = tempLibExtras
	}
	err = tl.Unmarshal(r, &t.ExitCode)
	if err != nil {
		return err
	}
	if (t.Mode>>2)&1 == 1 {
		var tempResult []byte
		err = tl.Unmarshal(r, &tempResult)
		if err != nil {
			return err
		}
		t.Result = tempResult
	}
	return nil
}

type LiteServerShardInfoC struct {
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	ShardDescr []byte
}

func (t LiteServerShardInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardDescr)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardDescr)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAllShardsInfoC struct {
	Id    TonNodeBlockIdExtC
	Proof []byte
	Data  []byte
}

func (t LiteServerAllShardsInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAllShardsInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionInfoC struct {
	Id          TonNodeBlockIdExtC
	Proof       []byte
	Transaction []byte
}

func (t LiteServerTransactionInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transaction)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transaction)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionListC struct {
	Ids          []TonNodeBlockIdExtC
	Transactions []byte
}

func (t LiteServerTransactionListC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transactions)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionListC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transactions)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionIdC struct {
	Mode    uint32
	Account *tl.Int256
	Lt      *uint64
	Hash    *tl.Int256
}

func (t LiteServerTransactionIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Account)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Hash)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempAccount tl.Int256
		err = tl.Unmarshal(r, &tempAccount)
		if err != nil {
			return err
		}
		t.Account = &tempAccount
	}
	if (t.Mode>>1)&1 == 1 {
		var tempLt uint64
		err = tl.Unmarshal(r, &tempLt)
		if err != nil {
			return err
		}
		t.Lt = &tempLt
	}
	if (t.Mode>>2)&1 == 1 {
		var tempHash tl.Int256
		err = tl.Unmarshal(r, &tempHash)
		if err != nil {
			return err
		}
		t.Hash = &tempHash
	}
	return nil
}

type LiteServerTransactionId3C struct {
	Account tl.Int256
	Lt      uint64
}

func (t LiteServerTransactionId3C) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionId3C) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Lt)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockTransactionsC struct {
	Id         TonNodeBlockIdExtC
	ReqCount   uint32
	Incomplete bool
	Ids        []LiteServerTransactionIdC
	Proof      []byte
}

func (t LiteServerBlockTransactionsC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ReqCount)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Incomplete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockTransactionsC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ReqCount)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Incomplete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockTransactionsExtC struct {
	Id           TonNodeBlockIdExtC
	ReqCount     uint32
	Incomplete   bool
	Transactions []byte
	Proof        []byte
}

func (t LiteServerBlockTransactionsExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ReqCount)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Incomplete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transactions)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockTransactionsExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ReqCount)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Incomplete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transactions)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignatureC struct {
	NodeIdShort tl.Int256
	Signature   []byte
}

func (t LiteServerSignatureC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.NodeIdShort)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signature)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignatureC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.NodeIdShort)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signature)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignatureSetC struct {
	ValidatorSetHash uint32
	CatchainSeqno    uint32
	Signatures       []LiteServerSignatureC
}

func (t LiteServerSignatureSetC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.ValidatorSetHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.CatchainSeqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signatures)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignatureSetC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.ValidatorSetHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.CatchainSeqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signatures)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockLink struct {
	tl.SumType
	LiteServerBlockLinkBack struct {
		ToKeyBlock bool
		From       TonNodeBlockIdExtC
		To         TonNodeBlockIdExtC
		DestProof  []byte
		Proof      []byte
		StateProof []byte
	}
	LiteServerBlockLinkForward struct {
		ToKeyBlock  bool
		From        TonNodeBlockIdExtC
		To          TonNodeBlockIdExtC
		DestProof   []byte
		ConfigProof []byte
		Signatures  LiteServerSignatureSet
	}
}

func (t LiteServerBlockLink) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "LiteServerBlockLinkBack":
		b, err = tl.Marshal(uint32(0xef7e1bef))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "LiteServerBlockLinkForward":
		b, err = tl.Marshal(uint32(0x520fce1c))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockLink) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xef7e1bef:
		t.SumType = "LiteServerBlockLinkBack"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return err
		}
	case 0x520fce1c:
		t.SumType = "LiteServerBlockLinkForward"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerPartialBlockProofC struct {
	Complete bool
	From     TonNodeBlockIdExtC
	To       TonNodeBlockIdExtC
	Steps    []LiteServerBlockLink
}

func (t LiteServerPartialBlockProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.From)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.To)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Steps)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerPartialBlockProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.From)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.To)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Steps)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerConfigInfoC struct {
	Mode        uint32
	Id          TonNodeBlockIdExtC
	StateProof  []byte
	ConfigProof []byte
}

func (t LiteServerConfigInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ConfigProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerConfigInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ConfigProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerValidatorStatsC struct {
	Mode       uint32
	Id         TonNodeBlockIdExtC
	Count      uint32
	Complete   bool
	StateProof []byte
	DataProof  []byte
}

func (t LiteServerValidatorStatsC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.DataProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerValidatorStatsC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.DataProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryResultC struct {
	Result []LiteServerLibraryEntryC
}

func (t LiteServerLibraryResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Result)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Result)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryResultWithProofC struct {
	Id         TonNodeBlockIdExtC
	Mode       uint32
	Result     []LiteServerLibraryEntryC
	StateProof []byte
	DataProof  []byte
}

func (t LiteServerLibraryResultWithProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Result)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.DataProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryResultWithProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Result)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.DataProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockLinkC struct {
	Id    TonNodeBlockIdExtC
	Proof []byte
}

func (t LiteServerShardBlockLinkC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockLinkC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockProofC struct {
	MasterchainId TonNodeBlockIdExtC
	Links         []LiteServerShardBlockLinkC
}

func (t LiteServerShardBlockProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.MasterchainId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Links)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.MasterchainId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Links)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLookupBlockResultC struct {
	Id                 TonNodeBlockIdExtC
	Mode               uint32
	McBlockId          TonNodeBlockIdExtC
	ClientMcStateProof []byte
	McBlockProof       []byte
	ShardLinks         []LiteServerShardBlockLinkC
	Header             []byte
	PrevHeader         []byte
}

func (t LiteServerLookupBlockResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ClientMcStateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardLinks)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Header)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.PrevHeader)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLookupBlockResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.McBlockId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ClientMcStateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.McBlockProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardLinks)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Header)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.PrevHeader)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerOutMsgQueueSizeC struct {
	Id   TonNodeBlockIdExtC
	Size uint32
}

func (t LiteServerOutMsgQueueSizeC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Size)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerOutMsgQueueSizeC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Size)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerOutMsgQueueSizesC struct {
	Shards               []LiteServerOutMsgQueueSizeC
	ExtMsgQueueSizeLimit uint32
}

func (t LiteServerOutMsgQueueSizesC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Shards)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ExtMsgQueueSizeLimit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerOutMsgQueueSizesC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Shards)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ExtMsgQueueSizeLimit)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountDispatchQueueInfoC struct {
	Addr  tl.Int256
	Size  uint64
	MinLt uint64
	MaxLt uint64
}

func (t LiteServerAccountDispatchQueueInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Addr)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Size)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.MinLt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.MaxLt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountDispatchQueueInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Addr)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Size)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.MinLt)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.MaxLt)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerDispatchQueueInfoC struct {
	Mode                  uint32
	Id                    TonNodeBlockIdExtC
	AccountDispatchQueues []LiteServerAccountDispatchQueueInfoC
	Complete              bool
	Proof                 []byte
}

func (t LiteServerDispatchQueueInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.AccountDispatchQueues)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerDispatchQueueInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.AccountDispatchQueues)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempProof []byte
		err = tl.Unmarshal(r, &tempProof)
		if err != nil {
			return err
		}
		t.Proof = tempProof
	}
	return nil
}

type LiteProxyRequestRateLimitC struct {
	Limit   uint32
	PerTime uint32
}

func (t LiteProxyRequestRateLimitC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Limit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.PerTime)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteProxyRequestRateLimitC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Limit)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.PerTime)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerDebugVerbosityC struct {
	Value uint32
}

func (t LiteServerDebugVerbosityC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Value)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerDebugVerbosityC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Value)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerGetMasterchainInfoRequest struct{}

func (t *LiteServerGetMasterchainInfoRequest) UnmarshalTL(r io.Reader) error {
	return nil
}

func (c *Client) LiteServerGetMasterchainInfo(ctx context.Context) (res LiteServerMasterchainInfoC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x89b5e62e)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x85832881 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetMasterchainInfoExtRequest struct {
	Mode uint32
}

func (t LiteServerGetMasterchainInfoExtRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetMasterchainInfoExtRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetMasterchainInfoExt(ctx context.Context, request LiteServerGetMasterchainInfoExtRequest) (res LiteServerMasterchainInfoExtC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetMasterchainInfoExtRequest `tlSumType:"70a671df"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa8cce0f5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetTimeRequest struct{}

func (t *LiteServerGetTimeRequest) UnmarshalTL(r io.Reader) error {
	return nil
}

func (c *Client) LiteServerGetTime(ctx context.Context) (res LiteServerCurrentTimeC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x16ad5a34)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xe953000d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetVersionRequest struct{}

func (t *LiteServerGetVersionRequest) UnmarshalTL(r io.Reader) error {
	return nil
}

func (c *Client) LiteServerGetVersion(ctx context.Context) (res LiteServerVersionC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x232b940b)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x5a0491e5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetBlockRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetBlock(ctx context.Context, request LiteServerGetBlockRequest) (res LiteServerBlockDataC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockRequest `tlSumType:"6377cf0d"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa574ed6c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetStateRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetStateRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetState(ctx context.Context, request LiteServerGetStateRequest) (res LiteServerBlockStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetStateRequest `tlSumType:"ba6e2eb6"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xabaddc0c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockHeaderRequest struct {
	Id   TonNodeBlockIdExtC
	Mode uint32
}

func (t LiteServerGetBlockHeaderRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetBlockHeaderRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetBlockHeader(ctx context.Context, request LiteServerGetBlockHeaderRequest) (res LiteServerBlockHeaderC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockHeaderRequest `tlSumType:"21ec069e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerSendMessageRequest struct {
	Body []byte
}

func (t LiteServerSendMessageRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Body)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSendMessageRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Body)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerSendMessage(ctx context.Context, request LiteServerSendMessageRequest) (res LiteServerSendMsgStatusC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerSendMessageRequest `tlSumType:"690ad482"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x3950e597 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAccountStateRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
}

func (t LiteServerGetAccountStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetAccountStateRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetAccountState(ctx context.Context, request LiteServerGetAccountStateRequest) (res LiteServerAccountStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAccountStateRequest `tlSumType:"6b890e25"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x7079c751 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAccountStatePrunnedRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
}

func (t LiteServerGetAccountStatePrunnedRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetAccountStatePrunnedRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetAccountStatePrunned(ctx context.Context, request LiteServerGetAccountStatePrunnedRequest) (res LiteServerAccountStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAccountStatePrunnedRequest `tlSumType:"5a698507"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x7079c751 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerRunSmcMethodRequest struct {
	Mode     uint32
	Id       TonNodeBlockIdExtC
	Account  LiteServerAccountIdC
	MethodId uint64
	Params   []byte
}

func (t LiteServerRunSmcMethodRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.MethodId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Params)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerRunSmcMethodRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.MethodId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Params)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerRunSmcMethod(ctx context.Context, request LiteServerRunSmcMethodRequest) (res LiteServerRunMethodResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerRunSmcMethodRequest `tlSumType:"5cc65dd2"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa39a616b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardInfoRequest struct {
	Id        TonNodeBlockIdExtC
	Workchain int32
	Shard     uint64
	Exact     bool
}

func (t LiteServerGetShardInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Exact)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetShardInfoRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Exact)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetShardInfo(ctx context.Context, request LiteServerGetShardInfoRequest) (res LiteServerShardInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardInfoRequest `tlSumType:"46a2f425"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x9fe6cd84 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAllShardsInfoRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetAllShardsInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetAllShardsInfoRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetAllShardsInfo(ctx context.Context, request LiteServerGetAllShardsInfoRequest) (res LiteServerAllShardsInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAllShardsInfoRequest `tlSumType:"74d3fd6b"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x98fe72d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetOneTransactionRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
	Lt      uint64
}

func (t LiteServerGetOneTransactionRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetOneTransactionRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Lt)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetOneTransaction(ctx context.Context, request LiteServerGetOneTransactionRequest) (res LiteServerTransactionInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetOneTransactionRequest `tlSumType:"d40f24ea"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xedeed47 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetTransactionsRequest struct {
	Count   uint32
	Account LiteServerAccountIdC
	Lt      uint64
	Hash    tl.Int256
}

func (t LiteServerGetTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetTransactionsRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Lt)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Hash)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetTransactions(ctx context.Context, request LiteServerGetTransactionsRequest) (res LiteServerTransactionListC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetTransactionsRequest `tlSumType:"1c40e7a1"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x6f26c60b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerLookupBlockRequest struct {
	Mode  uint32
	Id    TonNodeBlockIdC
	Lt    *uint64
	Utime *uint32
}

func (t LiteServerLookupBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Utime)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLookupBlockRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	if (t.Mode>>1)&1 == 1 {
		var tempLt uint64
		err = tl.Unmarshal(r, &tempLt)
		if err != nil {
			return err
		}
		t.Lt = &tempLt
	}
	if (t.Mode>>2)&1 == 1 {
		var tempUtime uint32
		err = tl.Unmarshal(r, &tempUtime)
		if err != nil {
			return err
		}
		t.Utime = &tempUtime
	}
	return nil
}

func (c *Client) LiteServerLookupBlock(ctx context.Context, request LiteServerLookupBlockRequest) (res LiteServerBlockHeaderC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerLookupBlockRequest `tlSumType:"fac8f71e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerLookupBlockWithProofRequest struct {
	Mode      uint32
	Id        TonNodeBlockIdC
	McBlockId TonNodeBlockIdExtC
	Lt        *uint64
	Utime     *uint32
}

func (t LiteServerLookupBlockWithProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Utime)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLookupBlockWithProofRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.McBlockId)
	if err != nil {
		return err
	}
	if (t.Mode>>1)&1 == 1 {
		var tempLt uint64
		err = tl.Unmarshal(r, &tempLt)
		if err != nil {
			return err
		}
		t.Lt = &tempLt
	}
	if (t.Mode>>2)&1 == 1 {
		var tempUtime uint32
		err = tl.Unmarshal(r, &tempUtime)
		if err != nil {
			return err
		}
		t.Utime = &tempUtime
	}
	return nil
}

func (c *Client) LiteServerLookupBlockWithProof(ctx context.Context, request LiteServerLookupBlockWithProofRequest) (res LiteServerLookupBlockResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerLookupBlockWithProofRequest `tlSumType:"9c045ff8"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x57c7ccc5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerListBlockTransactionsRequest struct {
	Id    TonNodeBlockIdExtC
	Mode  uint32
	Count uint32
	After *LiteServerTransactionId3C
}

func (t LiteServerListBlockTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>7)&1 == 1 {
		b, err = tl.Marshal(t.After)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerListBlockTransactionsRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	if (t.Mode>>7)&1 == 1 {
		var tempAfter LiteServerTransactionId3C
		err = tl.Unmarshal(r, &tempAfter)
		if err != nil {
			return err
		}
		t.After = &tempAfter
	}
	if (t.Mode>>6)&1 == 1 {
		// TODO: set optional field for True type
	}
	if (t.Mode>>5)&1 == 1 {
		// TODO: set optional field for True type
	}
	return nil
}

func (c *Client) LiteServerListBlockTransactions(ctx context.Context, request LiteServerListBlockTransactionsRequest) (res LiteServerBlockTransactionsC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerListBlockTransactionsRequest `tlSumType:"adfcc7da"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xbd8cad2b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerListBlockTransactionsExtRequest struct {
	Id    TonNodeBlockIdExtC
	Mode  uint32
	Count uint32
	After *LiteServerTransactionId3C
}

func (t LiteServerListBlockTransactionsExtRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>7)&1 == 1 {
		b, err = tl.Marshal(t.After)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerListBlockTransactionsExtRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	if (t.Mode>>7)&1 == 1 {
		var tempAfter LiteServerTransactionId3C
		err = tl.Unmarshal(r, &tempAfter)
		if err != nil {
			return err
		}
		t.After = &tempAfter
	}
	if (t.Mode>>6)&1 == 1 {
		// TODO: set optional field for True type
	}
	if (t.Mode>>5)&1 == 1 {
		// TODO: set optional field for True type
	}
	return nil
}

func (c *Client) LiteServerListBlockTransactionsExt(ctx context.Context, request LiteServerListBlockTransactionsExtRequest) (res LiteServerBlockTransactionsExtC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerListBlockTransactionsExtRequest `tlSumType:"0079dd5c"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xfb8ffce4 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockProofRequest struct {
	Mode        uint32
	KnownBlock  TonNodeBlockIdExtC
	TargetBlock *TonNodeBlockIdExtC
}

func (t LiteServerGetBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.KnownBlock)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.TargetBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetBlockProofRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.KnownBlock)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempTargetBlock TonNodeBlockIdExtC
		err = tl.Unmarshal(r, &tempTargetBlock)
		if err != nil {
			return err
		}
		t.TargetBlock = &tempTargetBlock
	}
	return nil
}

func (c *Client) LiteServerGetBlockProof(ctx context.Context, request LiteServerGetBlockProofRequest) (res LiteServerPartialBlockProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockProofRequest `tlSumType:"8aea9c44"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x8ed0d2c1 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigAllRequest struct {
	Mode uint32
	Id   TonNodeBlockIdExtC
}

func (t LiteServerGetConfigAllRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetConfigAllRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetConfigAll(ctx context.Context, request LiteServerGetConfigAllRequest) (res LiteServerConfigInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigAllRequest `tlSumType:"911b26b7"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigParamsRequest struct {
	Mode      uint32
	Id        TonNodeBlockIdExtC
	ParamList []uint32
}

func (t LiteServerGetConfigParamsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ParamList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetConfigParamsRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ParamList)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetConfigParams(ctx context.Context, request LiteServerGetConfigParamsRequest) (res LiteServerConfigInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigParamsRequest `tlSumType:"2a111c19"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetValidatorStatsRequest struct {
	Mode          uint32
	Id            TonNodeBlockIdExtC
	Limit         uint32
	StartAfter    *tl.Int256
	ModifiedAfter *uint32
}

func (t LiteServerGetValidatorStatsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Limit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.StartAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.ModifiedAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetValidatorStatsRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Limit)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempStartAfter tl.Int256
		err = tl.Unmarshal(r, &tempStartAfter)
		if err != nil {
			return err
		}
		t.StartAfter = &tempStartAfter
	}
	if (t.Mode>>2)&1 == 1 {
		var tempModifiedAfter uint32
		err = tl.Unmarshal(r, &tempModifiedAfter)
		if err != nil {
			return err
		}
		t.ModifiedAfter = &tempModifiedAfter
	}
	return nil
}

func (c *Client) LiteServerGetValidatorStats(ctx context.Context, request LiteServerGetValidatorStatsRequest) (res LiteServerValidatorStatsC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetValidatorStatsRequest `tlSumType:"091a58bc"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xb9f796d8 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetLibrariesRequest struct {
	LibraryList []tl.Int256
}

func (t LiteServerGetLibrariesRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.LibraryList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetLibrariesRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.LibraryList)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetLibraries(ctx context.Context, request LiteServerGetLibrariesRequest) (res LiteServerLibraryResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetLibrariesRequest `tlSumType:"d122b662"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x117ab96b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetLibrariesWithProofRequest struct {
	Id          TonNodeBlockIdExtC
	Mode        uint32
	LibraryList []tl.Int256
}

func (t LiteServerGetLibrariesWithProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.LibraryList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetLibrariesWithProofRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.LibraryList)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetLibrariesWithProof(ctx context.Context, request LiteServerGetLibrariesWithProofRequest) (res LiteServerLibraryResultWithProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetLibrariesWithProofRequest `tlSumType:"8c026c31"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x99370a1f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardBlockProofRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetShardBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetShardBlockProofRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetShardBlockProof(ctx context.Context, request LiteServerGetShardBlockProofRequest) (res LiteServerShardBlockProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardBlockProofRequest `tlSumType:"4ca60350"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x1d62a07a {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetOutMsgQueueSizesRequest struct {
	Mode  uint32
	Wc    *uint32
	Shard *uint64
}

func (t LiteServerGetOutMsgQueueSizesRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Wc)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Shard)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetOutMsgQueueSizesRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempWc uint32
		err = tl.Unmarshal(r, &tempWc)
		if err != nil {
			return err
		}
		t.Wc = &tempWc
	}
	if (t.Mode>>0)&1 == 1 {
		var tempShard uint64
		err = tl.Unmarshal(r, &tempShard)
		if err != nil {
			return err
		}
		t.Shard = &tempShard
	}
	return nil
}

func (c *Client) LiteServerGetOutMsgQueueSizes(ctx context.Context, request LiteServerGetOutMsgQueueSizesRequest) (res LiteServerOutMsgQueueSizesC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetOutMsgQueueSizesRequest `tlSumType:"7bc19c36"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xf8504a03 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetDispatchQueueInfoRequest struct {
	Mode        uint32
	Id          TonNodeBlockIdExtC
	AfterAddr   *tl.Int256
	MaxAccounts uint32
}

func (t LiteServerGetDispatchQueueInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.AfterAddr)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	b, err = tl.Marshal(t.MaxAccounts)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerGetDispatchQueueInfoRequest) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	if (t.Mode>>1)&1 == 1 {
		var tempAfterAddr tl.Int256
		err = tl.Unmarshal(r, &tempAfterAddr)
		if err != nil {
			return err
		}
		t.AfterAddr = &tempAfterAddr
	}
	err = tl.Unmarshal(r, &t.MaxAccounts)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		// TODO: set optional field for True type
	}
	return nil
}

func (c *Client) LiteServerGetDispatchQueueInfo(ctx context.Context, request LiteServerGetDispatchQueueInfoRequest) (res LiteServerDispatchQueueInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetDispatchQueueInfoRequest `tlSumType:"01e66bf3"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x5d1132d0 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteProxyGetRequestRateLimitRequest struct{}

func (t *LiteProxyGetRequestRateLimitRequest) UnmarshalTL(r io.Reader) error {
	return nil
}

func (c *Client) LiteProxyGetRequestRateLimit(ctx context.Context) (res LiteProxyRequestRateLimitC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0xf0f83e86)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x14cb3f0c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

var (
	// 0xf0f83e86
	decodeFuncLiteProxyGetRequestRateLimitRequest = decodeRequest(0xf0f83e86, LiteProxyGetRequestRateLimitRequestName, LiteProxyGetRequestRateLimitRequest{})
	// 0x5a698507
	decodeFuncLiteServerGetAccountStatePrunnedRequest = decodeRequest(0x5a698507, LiteServerGetAccountStatePrunnedRequestName, LiteServerGetAccountStatePrunnedRequest{})
	// 0x6b890e25
	decodeFuncLiteServerGetAccountStateRequest = decodeRequest(0x6b890e25, LiteServerGetAccountStateRequestName, LiteServerGetAccountStateRequest{})
	// 0x74d3fd6b
	decodeFuncLiteServerGetAllShardsInfoRequest = decodeRequest(0x74d3fd6b, LiteServerGetAllShardsInfoRequestName, LiteServerGetAllShardsInfoRequest{})
	// 0x21ec069e
	decodeFuncLiteServerGetBlockHeaderRequest = decodeRequest(0x21ec069e, LiteServerGetBlockHeaderRequestName, LiteServerGetBlockHeaderRequest{})
	// 0x8aea9c44
	decodeFuncLiteServerGetBlockProofRequest = decodeRequest(0x8aea9c44, LiteServerGetBlockProofRequestName, LiteServerGetBlockProofRequest{})
	// 0x6377cf0d
	decodeFuncLiteServerGetBlockRequest = decodeRequest(0x6377cf0d, LiteServerGetBlockRequestName, LiteServerGetBlockRequest{})
	// 0x911b26b7
	decodeFuncLiteServerGetConfigAllRequest = decodeRequest(0x911b26b7, LiteServerGetConfigAllRequestName, LiteServerGetConfigAllRequest{})
	// 0x2a111c19
	decodeFuncLiteServerGetConfigParamsRequest = decodeRequest(0x2a111c19, LiteServerGetConfigParamsRequestName, LiteServerGetConfigParamsRequest{})
	// 0x01e66bf3
	decodeFuncLiteServerGetDispatchQueueInfoRequest = decodeRequest(0x01e66bf3, LiteServerGetDispatchQueueInfoRequestName, LiteServerGetDispatchQueueInfoRequest{})
	// 0xd122b662
	decodeFuncLiteServerGetLibrariesRequest = decodeRequest(0xd122b662, LiteServerGetLibrariesRequestName, LiteServerGetLibrariesRequest{})
	// 0x8c026c31
	decodeFuncLiteServerGetLibrariesWithProofRequest = decodeRequest(0x8c026c31, LiteServerGetLibrariesWithProofRequestName, LiteServerGetLibrariesWithProofRequest{})
	// 0x70a671df
	decodeFuncLiteServerGetMasterchainInfoExtRequest = decodeRequest(0x70a671df, LiteServerGetMasterchainInfoExtRequestName, LiteServerGetMasterchainInfoExtRequest{})
	// 0x89b5e62e
	decodeFuncLiteServerGetMasterchainInfoRequest = decodeRequest(0x89b5e62e, LiteServerGetMasterchainInfoRequestName, LiteServerGetMasterchainInfoRequest{})
	// 0xd40f24ea
	decodeFuncLiteServerGetOneTransactionRequest = decodeRequest(0xd40f24ea, LiteServerGetOneTransactionRequestName, LiteServerGetOneTransactionRequest{})
	// 0x7bc19c36
	decodeFuncLiteServerGetOutMsgQueueSizesRequest = decodeRequest(0x7bc19c36, LiteServerGetOutMsgQueueSizesRequestName, LiteServerGetOutMsgQueueSizesRequest{})
	// 0x4ca60350
	decodeFuncLiteServerGetShardBlockProofRequest = decodeRequest(0x4ca60350, LiteServerGetShardBlockProofRequestName, LiteServerGetShardBlockProofRequest{})
	// 0x46a2f425
	decodeFuncLiteServerGetShardInfoRequest = decodeRequest(0x46a2f425, LiteServerGetShardInfoRequestName, LiteServerGetShardInfoRequest{})
	// 0xba6e2eb6
	decodeFuncLiteServerGetStateRequest = decodeRequest(0xba6e2eb6, LiteServerGetStateRequestName, LiteServerGetStateRequest{})
	// 0x16ad5a34
	decodeFuncLiteServerGetTimeRequest = decodeRequest(0x16ad5a34, LiteServerGetTimeRequestName, LiteServerGetTimeRequest{})
	// 0x1c40e7a1
	decodeFuncLiteServerGetTransactionsRequest = decodeRequest(0x1c40e7a1, LiteServerGetTransactionsRequestName, LiteServerGetTransactionsRequest{})
	// 0x091a58bc
	decodeFuncLiteServerGetValidatorStatsRequest = decodeRequest(0x091a58bc, LiteServerGetValidatorStatsRequestName, LiteServerGetValidatorStatsRequest{})
	// 0x232b940b
	decodeFuncLiteServerGetVersionRequest = decodeRequest(0x232b940b, LiteServerGetVersionRequestName, LiteServerGetVersionRequest{})
	// 0x0079dd5c
	decodeFuncLiteServerListBlockTransactionsExtRequest = decodeRequest(0x0079dd5c, LiteServerListBlockTransactionsExtRequestName, LiteServerListBlockTransactionsExtRequest{})
	// 0xadfcc7da
	decodeFuncLiteServerListBlockTransactionsRequest = decodeRequest(0xadfcc7da, LiteServerListBlockTransactionsRequestName, LiteServerListBlockTransactionsRequest{})
	// 0xfac8f71e
	decodeFuncLiteServerLookupBlockRequest = decodeRequest(0xfac8f71e, LiteServerLookupBlockRequestName, LiteServerLookupBlockRequest{})
	// 0x9c045ff8
	decodeFuncLiteServerLookupBlockWithProofRequest = decodeRequest(0x9c045ff8, LiteServerLookupBlockWithProofRequestName, LiteServerLookupBlockWithProofRequest{})
	// 0x5cc65dd2
	decodeFuncLiteServerRunSmcMethodRequest = decodeRequest(0x5cc65dd2, LiteServerRunSmcMethodRequestName, LiteServerRunSmcMethodRequest{})
	// 0x690ad482
	decodeFuncLiteServerSendMessageRequest = decodeRequest(0x690ad482, LiteServerSendMessageRequestName, LiteServerSendMessageRequest{})
)

var taggedRequestDecodeFunctions = map[uint32]reqDecoderFunc{
	0xf0f83e86: decodeFuncLiteProxyGetRequestRateLimitRequest,
	0x5a698507: decodeFuncLiteServerGetAccountStatePrunnedRequest,
	0x6b890e25: decodeFuncLiteServerGetAccountStateRequest,
	0x74d3fd6b: decodeFuncLiteServerGetAllShardsInfoRequest,
	0x21ec069e: decodeFuncLiteServerGetBlockHeaderRequest,
	0x8aea9c44: decodeFuncLiteServerGetBlockProofRequest,
	0x6377cf0d: decodeFuncLiteServerGetBlockRequest,
	0x911b26b7: decodeFuncLiteServerGetConfigAllRequest,
	0x2a111c19: decodeFuncLiteServerGetConfigParamsRequest,
	0x01e66bf3: decodeFuncLiteServerGetDispatchQueueInfoRequest,
	0xd122b662: decodeFuncLiteServerGetLibrariesRequest,
	0x8c026c31: decodeFuncLiteServerGetLibrariesWithProofRequest,
	0x70a671df: decodeFuncLiteServerGetMasterchainInfoExtRequest,
	0x89b5e62e: decodeFuncLiteServerGetMasterchainInfoRequest,
	0xd40f24ea: decodeFuncLiteServerGetOneTransactionRequest,
	0x7bc19c36: decodeFuncLiteServerGetOutMsgQueueSizesRequest,
	0x4ca60350: decodeFuncLiteServerGetShardBlockProofRequest,
	0x46a2f425: decodeFuncLiteServerGetShardInfoRequest,
	0xba6e2eb6: decodeFuncLiteServerGetStateRequest,
	0x16ad5a34: decodeFuncLiteServerGetTimeRequest,
	0x1c40e7a1: decodeFuncLiteServerGetTransactionsRequest,
	0x091a58bc: decodeFuncLiteServerGetValidatorStatsRequest,
	0x232b940b: decodeFuncLiteServerGetVersionRequest,
	0x0079dd5c: decodeFuncLiteServerListBlockTransactionsExtRequest,
	0xadfcc7da: decodeFuncLiteServerListBlockTransactionsRequest,
	0xfac8f71e: decodeFuncLiteServerLookupBlockRequest,
	0x9c045ff8: decodeFuncLiteServerLookupBlockWithProofRequest,
	0x5cc65dd2: decodeFuncLiteServerRunSmcMethodRequest,
	0x690ad482: decodeFuncLiteServerSendMessageRequest,
}

const (
	LiteProxyGetRequestRateLimitRequestName       RequestName = "liteProxy.getRequestRateLimit"
	LiteServerGetAccountStatePrunnedRequestName   RequestName = "liteServer.getAccountStatePrunned"
	LiteServerGetAccountStateRequestName          RequestName = "liteServer.getAccountState"
	LiteServerGetAllShardsInfoRequestName         RequestName = "liteServer.getAllShardsInfo"
	LiteServerGetBlockHeaderRequestName           RequestName = "liteServer.getBlockHeader"
	LiteServerGetBlockProofRequestName            RequestName = "liteServer.getBlockProof"
	LiteServerGetBlockRequestName                 RequestName = "liteServer.getBlock"
	LiteServerGetConfigAllRequestName             RequestName = "liteServer.getConfigAll"
	LiteServerGetConfigParamsRequestName          RequestName = "liteServer.getConfigParams"
	LiteServerGetDispatchQueueInfoRequestName     RequestName = "liteServer.getDispatchQueueInfo"
	LiteServerGetLibrariesRequestName             RequestName = "liteServer.getLibraries"
	LiteServerGetLibrariesWithProofRequestName    RequestName = "liteServer.getLibrariesWithProof"
	LiteServerGetMasterchainInfoExtRequestName    RequestName = "liteServer.getMasterchainInfoExt"
	LiteServerGetMasterchainInfoRequestName       RequestName = "liteServer.getMasterchainInfo"
	LiteServerGetOneTransactionRequestName        RequestName = "liteServer.getOneTransaction"
	LiteServerGetOutMsgQueueSizesRequestName      RequestName = "liteServer.getOutMsgQueueSizes"
	LiteServerGetShardBlockProofRequestName       RequestName = "liteServer.getShardBlockProof"
	LiteServerGetShardInfoRequestName             RequestName = "liteServer.getShardInfo"
	LiteServerGetStateRequestName                 RequestName = "liteServer.getState"
	LiteServerGetTimeRequestName                  RequestName = "liteServer.getTime"
	LiteServerGetTransactionsRequestName          RequestName = "liteServer.getTransactions"
	LiteServerGetValidatorStatsRequestName        RequestName = "liteServer.getValidatorStats"
	LiteServerGetVersionRequestName               RequestName = "liteServer.getVersion"
	LiteServerListBlockTransactionsExtRequestName RequestName = "liteServer.listBlockTransactionsExt"
	LiteServerListBlockTransactionsRequestName    RequestName = "liteServer.listBlockTransactions"
	LiteServerLookupBlockRequestName              RequestName = "liteServer.lookupBlock"
	LiteServerLookupBlockWithProofRequestName     RequestName = "liteServer.lookupBlockWithProof"
	LiteServerRunSmcMethodRequestName             RequestName = "liteServer.runSmcMethod"
	LiteServerSendMessageRequestName              RequestName = "liteServer.sendMessage"
)

